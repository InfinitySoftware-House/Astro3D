<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Web - N-Body Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            padding: 20px;
            background: rgba(15, 18, 25, 0.9);
            border: 1px solid rgba(0, 229, 255, 0.2);
            border-left: 3px solid #00e5ff;
            border-radius: 4px;
            backdrop-filter: blur(12px);
            color: #ccc;
            user-select: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 15px 0; font-size: 16px; text-transform: uppercase; letter-spacing: 2px; color: #00e5ff; font-weight: 800; }
        .stat { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 6px; color: #8a9ba8; }
        .val { font-family: 'Courier New', monospace; color: #fff; font-weight: bold; }

        .controls { margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px; }
        label { display: block; font-size: 11px; color: #00e5ff; margin-bottom: 6px; margin-top: 12px; text-transform: uppercase; letter-spacing: 0.5px; }
        
        input[type="range"] { width: 100%; height: 4px; background: #333; border-radius: 2px; -webkit-appearance: none; margin-bottom: 5px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; background: #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        select { width: 100%; background: #111; color: #fff; border: 1px solid #333; padding: 8px; border-radius: 4px; font-size: 12px; font-family: 'Courier New', monospace; outline: none; }
        select:focus { border-color: #00e5ff; }

        button {
            width: 100%; margin-top: 15px; padding: 10px; background: rgba(0, 229, 255, 0.1); border: 1px solid #00e5ff; 
            color: #00e5ff; font-size: 11px; text-transform: uppercase; font-weight: bold; cursor: pointer; letter-spacing: 1px;
            transition: all 0.2s;
        }
        button:hover { background: #00e5ff; color: #000; box-shadow: 0 0 15px rgba(0, 229, 255, 0.4); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.recording { background: #ff3333; border-color: #ff3333; color: #fff; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        
        input[type="number"] { width: 100%; background: #111; color: #fff; border: 1px solid #333; padding: 8px; border-radius: 4px; font-size: 12px; font-family: 'Courier New', monospace; outline: none; margin-bottom: 5px; }
        input[type="number"]:focus { border-color: #00e5ff; }
        
        #recordingStatus { font-size: 10px; color: #ff3333; text-align: center; margin-top: 8px; display: none; font-family: monospace; }
        
        #warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ff3333; background: rgba(0,0,0,0.9); padding: 20px; text-align: center;
            display: none; border: 1px solid #ff3333;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="ui-layer">
    <h1>Cosmic N-Body Sim</h1>
    <div class="stat"><span>PARTICLES</span> <span class="val" id="particleCount">131,072</span></div>
    <div class="stat"><span>COMPUTE GRID</span> <span class="val">64x64x16</span></div>
    <div class="stat"><span>SIMULATION TIME</span> <span class="val" id="fps">0 FPS</span></div>
    
    <div class="controls">
        <label>Particle Density (Reset Required)</label>
        <input type="range" id="particleCountSlider" min="16384" max="5000000" step="50000" value="131072">
        <div style="font-size: 10px; color: #666; text-align: right;" id="particleCountDisplay">131,072</div>
        
        <label>Time Step (Speed)</label>
        <input type="range" id="speed" min="0" max="2" step="0.05" value="0.2">
        
        <label>Initial Conditions</label>
        <select id="configSelect">
            <option value="web">CDM Cosmic Web (Filaments)</option>
            <option value="voids">Deep Field Voids (Bubbles)</option>
            <option value="collision">Galactic Merger</option>
            <option value="cluster">Globular Cluster</option>
        </select>

        <button id="resetBtn">Re-Initialize Simulation</button>
        
        <div style="margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
            <label>Video Recording Duration (minutes)</label>
            <input type="number" id="recordingDuration" min="0.1" max="60" step="0.1" value="5">
            <button id="recordBtn">Start Recording</button>
            <div id="recordingStatus"></div>
        </div>
        
        <div style="font-size: 10px; color: #445; margin-top: 15px; text-align: center; font-family: monospace;">
            [WASD] Navigate | [L-Click] Rotate
        </div>
    </div>
</div>

<div id="warning">Floating Point Textures not supported on this device.</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let TEXTURE_WIDTH = 362; 
let PARTICLES = TEXTURE_WIDTH * TEXTURE_WIDTH;
const GRID_DIM = 16;
const GRID_TEX_WIDTH = 64; 

const GRAVITY_CONSTANT = 6.0;
const SOFTENING = 2.5;
const UNIVERSE_SCALE = 5.0; // Larger universe for more "Sim" feel

// --- Shaders ---

const vsPass = `
    varying vec2 vUv;
    void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
    }
`;

const fsPosition = `
    uniform sampler2D texPos;
    uniform sampler2D texVel;
    uniform float delta;
    varying vec2 vUv;

    void main() {
        vec4 posState = texture2D(texPos, vUv);
        vec3 pos = posState.xyz;
        float mass = posState.w;
        vec3 vel = texture2D(texVel, vUv).xyz;

        pos += vel * delta;

        gl_FragColor = vec4(pos, mass);
    }
`;

const vsAggregator = `
    uniform sampler2D texPos;
    uniform float gridDim; 
    uniform float gridTexWidth; 
    uniform float gridCellSize;
    
    varying vec4 vParticleData;

    void main() {
        vec4 pData = texture2D(texPos, position.xy);
        vParticleData = pData;
        
        vec3 gridCoord = floor(pData.xyz / gridCellSize);
        gridCoord = clamp(gridCoord, 0.0, gridDim - 1.0);
        
        float index = gridCoord.x + gridCoord.y * gridDim + gridCoord.z * gridDim * gridDim;
        
        float col = mod(index, gridTexWidth);
        float row = floor(index / gridTexWidth);
        
        vec2 screenUV = (vec2(col, row) + 0.5) / gridTexWidth;
        
        gl_Position = vec4(screenUV * 2.0 - 1.0, 0.0, 1.0);
        gl_PointSize = 1.0;
    }
`;

const fsAggregator = `
    varying vec4 vParticleData;
    void main() {
        gl_FragColor = vec4(vParticleData.xyz * vParticleData.w, vParticleData.w);
    }
`;

const fsVelocity = `
    uniform sampler2D texPos;
    uniform sampler2D texVel;
    uniform sampler2D texGrid; 
    
    uniform float delta;
    uniform float gravityConstant;
    uniform float softening;
    uniform float gridDim; 
    uniform float gridCellSize;
    
    varying vec2 vUv;

    void main() {
        vec4 pData = texture2D(texPos, vUv);
        vec3 myPos = pData.xyz;
        vec3 myVel = texture2D(texVel, vUv).xyz;
        
        vec3 acc = vec3(0.0);
        float cellSize = gridCellSize;
        
        // Loop over grid texture (64x64)
        for(float y = 0.5; y < 64.0; y += 1.0) {
            for(float x = 0.5; x < 64.0; x += 1.0) {
                vec2 gridUV = vec2(x, y) / 64.0;
                vec4 cellData = texture2D(texGrid, gridUV);
                
                float cellMass = cellData.w;
                
                if(cellMass > 0.001) {
                    vec3 cellCoM = cellData.xyz / cellMass;
                    vec3 dir = cellCoM - myPos;
                    float distSq = dot(dir, dir);
                    float softSq = softening * softening + (cellSize * cellSize * 0.1); 
                    float dist = sqrt(distSq + softSq);
                    float f = (gravityConstant * cellMass) / (dist * dist * dist); 
                    acc += dir * f;
                }
            }
        }
        
        // Dark Energy / Hubble Expansion
        float distFromCenter = length(myPos);
        vec3 expansionDir = normalize(myPos);
        
        // This force counteracts gravity at large scales, stabilizing the web
        float expansionForce = 0.0005 * distFromCenter; 
        
        // Drag (Simulate Interstellar Medium friction slightly)
        myVel *= 0.999; 

        if (distFromCenter > 200.0) {
             acc += expansionDir * expansionForce;
        }

        myVel += acc * delta;
        
        gl_FragColor = vec4(myVel, 0.0);
    }
`;

// VISUAL SHADER: Adds "Temperature" coloring based on local density/energy
const vsVisual = `
    uniform sampler2D texPos;
    uniform sampler2D texVel;
    varying vec3 vColor;
    varying float vAlpha;
    varying float vSize;

    void main() {
        vec4 posData = texture2D(texPos, position.xy);
        vec3 vel = texture2D(texVel, position.xy).xyz;
        
        vec3 pos = posData.xyz;
        float mass = posData.w;
        
        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        
        float dist = -mvPosition.z;
        dist = max(dist, 0.1); // Prevent division by zero and ensure minimum distance
        float speed = length(vel);
        
        // Simulation Color Palette (Heatmap)
        // Cold/Slow/Void = Deep Purple/Blue
        // Medium/Filament = Cyan/Green
        // Hot/Cluster = Yellow/White
        
        vec3 cVoid = vec3(0.05, 0.0, 0.2);
        vec3 cFilament = vec3(0.0, 0.8, 1.0);
        vec3 cCluster = vec3(1.0, 0.9, 0.7);
        
        // Calculate "Energy" for coloring
        float energy = speed * 0.15 + (mass * 0.05);
        
        if (energy < 0.5) {
            vColor = mix(cVoid, cFilament, energy * 2.0);
        } else {
            vColor = mix(cFilament, cCluster, min(1.0, (energy - 0.5) * 2.0));
        }

        // Highlight super-heavy particles (Black Holes/Cluster Cores)
        if (mass > 50.0) {
            vColor = vec3(1.0, 1.0, 1.0);
            gl_PointSize = clamp(9000.0 / dist, 2.0, 4096.0); // Brighter, more visible cores
            vAlpha = 1.0;
        } else {
            gl_PointSize = clamp((4500.0 / dist) * max(0.8, mass * 0.7), 1.5, 4096.0);
            vAlpha = min(1.0, mass * 0.4 + 0.5);
        }
        
        vSize = gl_PointSize;
    }
`;

const fsVisual = `
    varying vec3 vColor;
    varying float vAlpha;
    void main() {
        vec2 coord = gl_PointCoord - vec2(0.5);
        float distSq = dot(coord, coord);
        if (distSq > 0.25) discard;
        
        float strength = 1.0 - (distSq * 4.0);
        strength = pow(strength, 1.4);
        strength = min(1.0, strength * 1.35);
        
        gl_FragColor = vec4(vColor, vAlpha * strength);
    }
`;

let renderer, scene, camera, controls;
let simMode = 'web'; 

let fboPos1, fboPos2, fboVel1, fboVel2, fboGrid;
let sceneSim, cameraSim, sceneGrid, geometryQuad;
let matPos, matVel, matGrid, matDisplay;

let stats = { fps: 0, ms: 0 };
let lastTime = 0;
let frames = 0;
let simSpeed = 0.2; // Slower default for majesty
const keys = {};

// Video recording variables
let mediaRecorder = null;
let recordedChunks = [];
let recordingStartTime = 0;
let recordingDuration = 0;
let recordingTimer = null;
let isRecording = false; 

init();
animate();

function init() {
    const canvas = document.createElement('canvas');
    document.body.appendChild(canvas);
    
    renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    if (!renderer.capabilities.isWebGL2 && !renderer.extensions.get('OES_texture_float')) {
        document.getElementById('warning').style.display = 'block';
        return;
    }

    scene = new THREE.Scene();
    // Dark background for deep space
    scene.fog = new THREE.FogExp2(0x050505, 0.0002);
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.001, 100000 * UNIVERSE_SCALE);
    camera.position.set(0, 0, 1200 * UNIVERSE_SCALE); // Start further back
    
    controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.mouseButtons = {
        LEFT: THREE.MOUSE.ROTATE,
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.PAN
    };

    sceneSim = new THREE.Scene();
    sceneGrid = new THREE.Scene();
    cameraSim = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    geometryQuad = new THREE.PlaneGeometry(2, 2);

    initFBOs();
    initMaterials();
    initParticles();
    setupUI();
    window.addEventListener('resize', onResize);
    
    window.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
    window.addEventListener('blur', () => Object.keys(keys).forEach(k => keys[k] = false));
}

function createTexture() {
    return new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_WIDTH, {
        type: THREE.FloatType, format: THREE.RGBAFormat, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter
    });
}

function initFBOs() {
    fboPos1 = createTexture(); fboPos2 = createTexture();
    fboVel1 = createTexture(); fboVel2 = createTexture();
    fboGrid = new THREE.WebGLRenderTarget(GRID_TEX_WIDTH, GRID_TEX_WIDTH, {
        type: THREE.FloatType, format: THREE.RGBAFormat, minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter
    });
}

// --- CORE GENERATION ALGORITHM ---
function initData(mode) {
    const dataPos = new Float32Array(PARTICLES * 4);
    const dataVel = new Float32Array(PARTICLES * 4);
    
    // Config vars
    const spread = 2000 * UNIVERSE_SCALE;
    
    if (mode === 'web' || mode === 'voids') {
        // --- ALGORITHM: PROCEDURAL FILAMENTS & VOIDS ---
        
        // 1. Generate Structural Nodes (Galaxy Clusters)
        const nodeCount = 40;
        const nodes = [];
        for(let i=0; i<nodeCount; i++) {
            nodes.push(new THREE.Vector3(
                (Math.random()-0.5) * spread,
                (Math.random()-0.5) * spread,
                (Math.random()-0.5) * spread
            ));
        }

        // 2. Generate Connectivity (Edges/Filaments)
        // Simple nearest-neighbor graph to create web
        const filaments = [];
        for(let i=0; i<nodeCount; i++) {
            // Connect to 2 or 3 nearest neighbors
            const dists = nodes.map((n, idx) => ({ idx, dist: nodes[i].distanceTo(n) }));
            dists.sort((a,b) => a.dist - b.dist);
            // Connect to closest 2 (skipping self at 0)
            for(let k=1; k<=3; k++) {
                if (dists[k]) filaments.push({ start: nodes[i], end: nodes[dists[k].idx] });
            }
        }

        for (let i = 0; i < PARTICLES; i++) {
            let x, y, z, m, vx, vy, vz;
            
            const isBackround = Math.random() < 0.05; // 5% background radiation particles

            if (isBackround && mode !== 'voids') {
                // Randomly scattered particles (Voids aren't perfectly empty)
                x = (Math.random()-0.5) * spread * 1.5;
                y = (Math.random()-0.5) * spread * 1.5;
                z = (Math.random()-0.5) * spread * 1.5;
                m = 0.5; // Light
                vx = vy = vz = 0;
            } else {
                // Select a filament
                const fil = filaments[Math.floor(Math.random() * filaments.length)];
                let t = Math.random();
                
                // Bias t towards the ends (clusters are denser)
                if (Math.random() > 0.5) t = t * t; 
                else t = 1 - (1-t)*(1-t);

                // Base position on filament
                let px = (1-t) * fil.start.x + t * fil.end.x;
                let py = (1-t) * fil.start.y + t * fil.end.y;
                let pz = (1-t) * fil.start.z + t * fil.end.z;

                // Sine Wave Perturbation (Warp the straight lines)
                // This makes them look like organic veins, not wires
                const warpFreq = 0.005;
                const warpAmp = 100.0;
                px += Math.sin(py * warpFreq) * warpAmp;
                py += Math.cos(pz * warpFreq) * warpAmp;
                pz += Math.sin(px * warpFreq) * warpAmp;

                // Thickness/Scatter
                // Voids mode has thinner filaments
                let thickness = (mode === 'voids' ? 40 : 100) * UNIVERSE_SCALE;
                
                // Density Function: Use noise to clump particles
                // If noise is low, push particle further out (create gaps in filament)
                const densityNoise = Math.sin(px*0.01) + Math.cos(py*0.013) + Math.sin(pz*0.007);
                if (densityNoise < 0) thickness *= 3.0; // Puff out low density areas

                // Gaussian scatter from the filament spine
                const r = (Math.random() + Math.random() + Math.random()) / 3.0 * thickness;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;

                x = px + r * Math.sin(phi) * Math.cos(theta);
                y = py + r * Math.sin(phi) * Math.sin(theta);
                z = pz + r * Math.cos(phi);

                // Mass depends on density
                m = (1.0 - (r/thickness)) * 3.0;
                if (m < 0.5) m = 0.5;

                // Super Cluster Cores
                if (t < 0.05 || t > 0.95) {
                    m = 10.0 + Math.random() * 20.0; // Heavy cluster center
                }

                // Initial Velocity:
                // 1. Flow along filament towards nearest node
                const dirToStart = new THREE.Vector3().subVectors(fil.start, new THREE.Vector3(x,y,z)).normalize();
                const dirToEnd = new THREE.Vector3().subVectors(fil.end, new THREE.Vector3(x,y,z)).normalize();
                
                const flowDir = (t < 0.5) ? dirToStart : dirToEnd;
                const flowSpeed = Math.random() * 5.0;

                vx = flowDir.x * flowSpeed;
                vy = flowDir.y * flowSpeed;
                vz = flowDir.z * flowSpeed;

                // 2. Slight rotation around filament axis (Angular momentum)
                // (Simplified as random perpendicular drift)
                vx += (Math.random()-0.5) * 4.0;
                vy += (Math.random()-0.5) * 4.0;
                vz += (Math.random()-0.5) * 4.0;
            }

            const idx = i * 4;
            dataPos[idx] = x; dataPos[idx+1] = y; dataPos[idx+2] = z; dataPos[idx+3] = m;
            dataVel[idx] = vx; dataVel[idx+1] = vy; dataVel[idx+2] = vz; dataVel[idx+3] = 0;
        }

    } else if (mode === 'collision') {
        // --- GALAXY COLLISION ---
        for (let i = 0; i < PARTICLES; i++) {
            let x, y, z, vx, vy, vz, m;
            
            // Galaxy 1 vs Galaxy 2
            const isGal1 = i < PARTICLES/2;
            const centerX = isGal1 ? -400 : 400;
            const centerZ = isGal1 ? 0 : 0;
            
            // Spiral Arms Math
            const armOffset = Math.random() * Math.PI * 2;
            const dist = Math.random(); // 0 to 1
            // Power law distribution for brighter core
            const r = (dist * dist) * 500 + 10; 
            
            const arms = 3;
            const angle = dist * Math.PI * 4 * arms + armOffset;

            x = Math.cos(angle) * r;
            z = Math.sin(angle) * r;
            y = (Math.random()-0.5) * (r * 0.1); // Flattened disk

            // Rotate Galaxy 2 to make collision messy
            if (!isGal1) {
                const tempZ = z;
                z = y; 
                y = tempZ; // Flip axis
            }

            x += centerX;
            z += centerZ;

            // Orbital Velocity (Sqrt for realistic falloff)
            const vMag = Math.sqrt(15000 / (r + 10));
            vx = -Math.sin(angle) * vMag;
            vz = Math.cos(angle) * vMag;
            vy = 0;

            // Add collision velocity
            if (isGal1) vx += 15; else vx -= 15;

            // Randomize slightly
            vx += (Math.random()-0.5); 
            vy += (Math.random()-0.5); 
            vz += (Math.random()-0.5);

            m = (1.0 - dist) * 5.0 + 0.5; // Core is heavier
            if (dist < 0.05) m = 50.0; // Supermassive black hole candidates

            const idx = i * 4;
            dataPos[idx] = x; dataPos[idx+1] = y; dataPos[idx+2] = z; dataPos[idx+3] = m;
            dataVel[idx] = vx; dataVel[idx+1] = vy; dataVel[idx+2] = vz; dataVel[idx+3] = 0;
        }
    } else {
        // --- GLOBULAR CLUSTER ---
        for (let i = 0; i < PARTICLES; i++) {
            // Gaussian Sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = Math.pow(Math.random(), 1/3) * 600; // Uniform sphere

            let x = r * Math.sin(phi) * Math.cos(theta);
            let y = r * Math.sin(phi) * Math.sin(theta);
            let z = r * Math.cos(phi);

            let m = Math.random() * 2 + 0.5;
            
            // Initial Random Velocity (Thermal equilibrium)
            let vx = (Math.random()-0.5) * 5;
            let vy = (Math.random()-0.5) * 5;
            let vz = (Math.random()-0.5) * 5;

            const idx = i * 4;
            dataPos[idx] = x; dataPos[idx+1] = y; dataPos[idx+2] = z; dataPos[idx+3] = m;
            dataVel[idx] = vx; dataVel[idx+1] = vy; dataVel[idx+2] = vz; dataVel[idx+3] = 0;
        }
    }
    
    const texPos = new THREE.DataTexture(dataPos, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    texPos.needsUpdate = true;
    const texVel = new THREE.DataTexture(dataVel, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    texVel.needsUpdate = true;
    
    const tmp = new THREE.MeshBasicMaterial({map:texPos});
    const mesh = new THREE.Mesh(geometryQuad, tmp);
    sceneSim.add(mesh);
    renderer.setRenderTarget(fboPos1); renderer.render(sceneSim, cameraSim);
    renderer.setRenderTarget(fboPos2); renderer.render(sceneSim, cameraSim);
    tmp.map = texVel;
    renderer.setRenderTarget(fboVel1); renderer.render(sceneSim, cameraSim);
    renderer.setRenderTarget(fboVel2); renderer.render(sceneSim, cameraSim);
    sceneSim.remove(mesh);
    tmp.dispose(); texPos.dispose(); texVel.dispose();
}

function initMaterials() {
    matPos = new THREE.ShaderMaterial({
        uniforms: { texPos: {value:null}, texVel: {value:null}, delta: {value:0.0} },
        vertexShader: vsPass, fragmentShader: fsPosition
    });
    matVel = new THREE.ShaderMaterial({
        uniforms: { 
            texPos: {value:null}, texVel: {value:null}, texGrid: {value:null}, delta: {value:0.0},
            gravityConstant: {value: GRAVITY_CONSTANT * UNIVERSE_SCALE},
            softening: {value: SOFTENING},
            gridDim: {value:GRID_DIM}, gridTexWidth: {value:GRID_TEX_WIDTH}, gridCellSize: {value:100.0 * UNIVERSE_SCALE}
        },
        vertexShader: vsPass, fragmentShader: fsVelocity
    });
    matGrid = new THREE.ShaderMaterial({
        uniforms: { texPos: {value:null}, gridDim: {value:GRID_DIM}, gridTexWidth: {value:GRID_TEX_WIDTH}, gridCellSize: {value:100.0 * UNIVERSE_SCALE} },
        vertexShader: vsAggregator, fragmentShader: fsAggregator, blending: THREE.AdditiveBlending, transparent: true, depthTest: false, depthWrite: false
    });
    matDisplay = new THREE.ShaderMaterial({
        uniforms: { texPos: {value:null}, texVel: {value:null} },
        vertexShader: vsVisual, fragmentShader: fsVisual, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
    });
}

function initParticles() {
    initData(simMode);
    
    const geo = new THREE.BufferGeometry();
    const uvs = new Float32Array(PARTICLES * 3);
    for (let i = 0; i < PARTICLES; i++) {
        uvs[i*3] = (i % TEXTURE_WIDTH) / TEXTURE_WIDTH + (0.5/TEXTURE_WIDTH);
        uvs[i*3+1] = Math.floor(i / TEXTURE_WIDTH) / TEXTURE_WIDTH + (0.5/TEXTURE_WIDTH);
        uvs[i*3+2] = 0;
    }
    geo.setAttribute('position', new THREE.BufferAttribute(uvs, 3));
    
    sceneSim.add(new THREE.Mesh(geometryQuad, matPos)); 
    sceneGrid.add(new THREE.Points(geo, matGrid)); 
    const displayPoints = new THREE.Points(geo, matDisplay);
    displayPoints.frustumCulled = false;
    scene.add(displayPoints); 
}

function formatNumber(num) { return num.toLocaleString('en-US'); }

function updateParticleCount(desiredCount) {
    TEXTURE_WIDTH = Math.round(Math.sqrt(desiredCount));
    PARTICLES = TEXTURE_WIDTH * TEXTURE_WIDTH;
    document.getElementById('particleCount').textContent = formatNumber(PARTICLES);
    document.getElementById('particleCountDisplay').textContent = formatNumber(PARTICLES);
    reinitializeSimulation();
}

function reinitializeSimulation() {
    if (fboPos1) fboPos1.dispose(); if (fboPos2) fboPos2.dispose();
    if (fboVel1) fboVel1.dispose(); if (fboVel2) fboVel2.dispose();
    if (fboGrid) fboGrid.dispose();
    
    while(sceneSim.children.length > 0) sceneSim.remove(sceneSim.children[0]);
    while(sceneGrid.children.length > 0) sceneGrid.remove(sceneGrid.children[0]);
    while(scene.children.length > 0) {
        const obj = scene.children[0];
        if (obj instanceof THREE.Points) {
            scene.remove(obj); obj.geometry.dispose(); obj.material.dispose();
        } else scene.remove(obj);
    }
    
    initFBOs();
    initParticles();
}

function setupUI() {
    document.getElementById('particleCount').textContent = formatNumber(PARTICLES);
    document.getElementById('particleCountDisplay').textContent = formatNumber(PARTICLES);
    document.getElementById('speed').addEventListener('input', e => simSpeed = parseFloat(e.target.value));
    document.getElementById('configSelect').addEventListener('change', e => { simMode = e.target.value; initData(simMode); });
    document.getElementById('resetBtn').addEventListener('click', () => { initData(simMode); });
    document.getElementById('particleCountSlider').addEventListener('change', e => { updateParticleCount(parseInt(e.target.value)); });
    
    // Video recording controls
    const recordBtn = document.getElementById('recordBtn');
    const durationInput = document.getElementById('recordingDuration');
    const statusDiv = document.getElementById('recordingStatus');
    
    recordBtn.addEventListener('click', toggleRecording);
    durationInput.addEventListener('input', e => {
        if (!isRecording) {
            recordingDuration = parseFloat(e.target.value) * 60; // Convert to seconds
        }
    });
    
    // Initialize duration
    recordingDuration = parseFloat(durationInput.value) * 60;
}

async function toggleRecording() {
    if (isRecording) {
        stopRecording();
    } else {
        await startRecording();
    }
}

async function startRecording() {
    try {
        const canvas = renderer.domElement;
        const stream = canvas.captureStream(30); // 30 FPS
        
        const options = {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: 30000000 // 30 Mbps
        };
        
        // Fallback to vp8 if vp9 is not supported
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options.mimeType = 'video/webm;codecs=vp8';
        }
        
        // Final fallback
        if (!MediaRecorder.isTypeSupported(options.mimeType)) {
            options.mimeType = 'video/webm';
        }
        
        mediaRecorder = new MediaRecorder(stream, options);
        recordedChunks = [];
        
        mediaRecorder.ondataavailable = (event) => {
            if (event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        };
        
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `astro3d-recording-${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            isRecording = false;
            updateRecordingUI();
        };
        
        mediaRecorder.start();
        isRecording = true;
        recordingStartTime = performance.now();
        
        const durationInput = document.getElementById('recordingDuration');
        recordingDuration = parseFloat(durationInput.value) * 60; // Convert minutes to seconds
        
        // Auto-stop after duration
        recordingTimer = setTimeout(() => {
            stopRecording();
        }, recordingDuration * 1000);
        
        updateRecordingUI();
    } catch (error) {
        console.error('Error starting recording:', error);
        alert('Failed to start recording: ' + error.message);
        isRecording = false;
        updateRecordingUI();
    }
}

function stopRecording() {
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
    }
    if (recordingTimer) {
        clearTimeout(recordingTimer);
        recordingTimer = null;
    }
    updateRecordingUI();
}

function updateRecordingUI() {
    const recordBtn = document.getElementById('recordBtn');
    const durationInput = document.getElementById('recordingDuration');
    const statusDiv = document.getElementById('recordingStatus');
    
    if (isRecording) {
        recordBtn.textContent = 'Stop Recording';
        recordBtn.classList.add('recording');
        durationInput.disabled = true;
        statusDiv.style.display = 'block';
        
        // Update status with remaining time
        const updateStatus = () => {
            if (!isRecording) return;
            const elapsed = (performance.now() - recordingStartTime) / 1000;
            const remaining = Math.max(0, recordingDuration - elapsed);
            const minutes = Math.floor(remaining / 60);
            const seconds = Math.floor(remaining % 60);
            statusDiv.textContent = `Recording... ${minutes}:${seconds.toString().padStart(2, '0')} remaining`;
            if (isRecording) {
                setTimeout(updateStatus, 1000);
            }
        };
        updateStatus();
    } else {
        recordBtn.textContent = 'Start Recording';
        recordBtn.classList.remove('recording');
        durationInput.disabled = false;
        statusDiv.style.display = 'none';
        statusDiv.textContent = '';
    }
}

function onResize() {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
}

function animate() {
    requestAnimationFrame(animate);
    const now = performance.now();
    let dt = Math.min((now - lastTime) / 1000, 0.1);
    lastTime = now;
    
    frames++;
    if (now - stats.ms > 500) {
        document.getElementById('fps').textContent = Math.round(frames * 1000 / (now - stats.ms)) + " FPS";
        stats.ms = now; frames = 0;
    }

    if (simSpeed > 0) {
        // Physics Pipeline
        renderer.setRenderTarget(fboGrid); renderer.clearColor();
        matGrid.uniforms.texPos.value = fboPos1.texture;
        renderer.render(sceneGrid, cameraSim);

        sceneSim.children[0].material = matVel;
        matVel.uniforms.texPos.value = fboPos1.texture;
        matVel.uniforms.texVel.value = fboVel1.texture;
        matVel.uniforms.texGrid.value = fboGrid.texture;
        matVel.uniforms.delta.value = dt * simSpeed;
        renderer.setRenderTarget(fboVel2); renderer.render(sceneSim, cameraSim);
        let t = fboVel1; fboVel1 = fboVel2; fboVel2 = t;

        sceneSim.children[0].material = matPos;
        matPos.uniforms.texPos.value = fboPos1.texture;
        matPos.uniforms.texVel.value = fboVel1.texture;
        matPos.uniforms.delta.value = dt * simSpeed;
        renderer.setRenderTarget(fboPos2); renderer.render(sceneSim, cameraSim);
        t = fboPos1; fboPos1 = fboPos2; fboPos2 = t;
    }

    renderer.setRenderTarget(null);
    matDisplay.uniforms.texPos.value = fboPos1.texture;
    matDisplay.uniforms.texVel.value = fboVel1.texture;
    
    // Smooth Camera Movement
    const moveSpeed = 400 * dt * UNIVERSE_SCALE;
    const fwd = new THREE.Vector3(); 
    camera.getWorldDirection(fwd);
    const rgt = new THREE.Vector3().crossVectors(fwd, camera.up).normalize();
    const up = new THREE.Vector3().crossVectors(rgt, fwd).normalize();
    
    if (keys['w']) camera.position.addScaledVector(fwd, moveSpeed);
    if (keys['s']) camera.position.addScaledVector(fwd, -moveSpeed);
    if (keys['a']) camera.position.addScaledVector(rgt, -moveSpeed);
    if (keys['d']) camera.position.addScaledVector(rgt, moveSpeed);
    
    // Update controls target to follow camera movement
    controls.target.copy(camera.position).addScaledVector(fwd, 100 * UNIVERSE_SCALE);
    controls.update();
    
    renderer.render(scene, camera);
}
</script>
</body>
</html>
