<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N-Body: Cube & Black Holes</title>
    <style>
        body { margin: 0; background-color: #010103; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px; width: 280px;
            color: #88aaff; background: rgba(0, 5, 15, 0.9);
            border: 1px solid #335588; padding: 15px;
            font-family: 'Courier New', monospace;
            pointer-events: auto; user-select: none; z-index: 10;
            box-shadow: 0 0 20px rgba(0,10,30,0.8);
        }
        h1 { margin: 0 0 10px 0; font-size: 16px; text-transform: uppercase; border-bottom: 1px solid #335588; padding-bottom: 5px; color: #ddeeff; }
        .row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px; }
        input[type=range] { width: 100%; margin: 5px 0 10px 0; -webkit-appearance: none; background: #001133; height: 2px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #4488ff; border-radius: 50%; cursor: pointer; box-shadow: 0 0 5px #4488ff; }
        button { 
            width: 100%; background: #002244; color: #88ccff; border: 1px solid #335588; 
            padding: 8px; cursor: pointer; text-transform: uppercase; font-weight: bold; margin-top: 10px;
        }
        button:hover { background: #4488ff; color: #000; box-shadow: 0 0 10px #4488ff; }
        .note { font-size: 10px; color: #6688aa; margin-top: 5px; font-style: italic; }
        #loadingScreen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #010103; z-index: 1000; display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            color: #88aaff; font-family: 'Courier New', monospace;
        }
        #loadingScreen.hidden { display: none; }
        .loadingSpinner {
            width: 60px; height: 60px; border: 4px solid rgba(68, 136, 255, 0.2);
            border-top-color: #4488ff; border-radius: 50%; animation: spin 1s linear infinite;
            margin-bottom: 20px; box-shadow: 0 0 15px rgba(68, 136, 255, 0.3);
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loadingText { font-size: 18px; margin-bottom: 10px; color: #ddeeff; }
        .loadingProgress { font-size: 14px; color: #6688aa; }
    </style>
</head>
<body>

<div id="loadingScreen">
    <div class="loadingSpinner"></div>
    <div class="loadingText">Initializing Universe</div>
    <div class="loadingProgress" id="loadingProgress">Preparing...</div>
</div>

<div id="ui">
    <h1>Cube & Black Holes</h1>
    <div class="row"><span>Particles:</span> <span id="countDisplay">65536</span></div>
    <div class="row"><span>Nodes:</span> <span id="nodeDisplay">0</span></div>
    <div class="row"><span>FPS:</span> <span id="fpsDisplay">0</span></div>
    
    <label>Theta (Accuracy vs Speed)</label>
    <input type="range" id="thetaSlider" min="0.1" max="1.5" step="0.1" value="0.5">
    
    <label>Tree Update Rate</label>
    <div class="row" style="margin-bottom:0"><span style="font-size:10px">Updates tree every X frames</span></div>
    <input type="range" id="treeRateSlider" min="1" max="10" step="1" value="2">

    <label>Sim Speed: <span id="speedValue">1.0x</span></label>
    <input type="range" id="speedSlider" min="0" max="50.0" step="0.1" value="1.0">

    <label>Particle Count</label>
    <input type="range" id="particleCountSlider" min="4096" max="131072" step="4096" value="65536">
    <div class="row" style="margin-top: -5px;"><span style="font-size:10px" id="particleCountValue">65536</span></div>

    <button id="resetBtn">Reset: Spawn Cube</button>
    <div class="note">WASD + QE + Shift to fly</div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- CONFIGURATION ---
let COUNT = 65536; 
function getTextureWidth(count) {
    return Math.ceil(Math.sqrt(count));
}
let TEXTURE_WIDTH = getTextureWidth(COUNT);
let MAX_NODES = COUNT * 2; 
const NODE_TEX_WIDTH = 256; 
const MAX_TREE_DEPTH = 32;

// Physics Config
let THETA = 0.5;
const BASE_DT = 0.01; 
let TIME_STEP = BASE_DT; 

let TREE_UPDATE_INTERVAL = 2; 
const GRAVITY = 1.5; 
const SOFTENING = 4.0; 

// --- MEMORY POOLS (CPU) ---
const poolNext = new Int32Array(MAX_NODES * 8); 
const poolCount = new Int32Array(MAX_NODES);    
const poolMass = new Float32Array(MAX_NODES);
const poolPosX = new Float32Array(MAX_NODES);
const poolPosY = new Float32Array(MAX_NODES);
const poolPosZ = new Float32Array(MAX_NODES);
const poolMin = new Float32Array(MAX_NODES * 3);
const poolMax = new Float32Array(MAX_NODES * 3);

// Texture Data Buffers
const treeDataPosMass = new Float32Array(NODE_TEX_WIDTH * NODE_TEX_WIDTH * 4);
const treeDataInfo = new Float32Array(NODE_TEX_WIDTH * NODE_TEX_WIDTH * 4);

let nodePtr = 0; 
let gpuSerialIndex = 0;

function resetPool() { nodePtr = 0; }

function allocNode(minX, minY, minZ, maxX, maxY, maxZ) {
    const id = nodePtr++;
    if (id >= MAX_NODES) return -1; 
    poolMass[id] = 0;
    poolPosX[id] = 0; poolPosY[id] = 0; poolPosZ[id] = 0;
    poolCount[id] = 0;
    const idx3 = id * 3;
    poolMin[idx3] = minX; poolMin[idx3+1] = minY; poolMin[idx3+2] = minZ;
    poolMax[idx3] = maxX; poolMax[idx3+1] = maxY; poolMax[idx3+2] = maxZ;
    const idx8 = id * 8;
    for(let i=0; i<8; i++) poolNext[idx8+i] = -1;
    return id;
}

function insertParticle(nodeId, x, y, z, m, depth) {
    if (nodeId === -1) return;
    const pm = poolMass[nodeId];
    const newMass = pm + m;
    if (newMass > 0) {
        poolPosX[nodeId] = (poolPosX[nodeId] * pm + x * m) / newMass;
        poolPosY[nodeId] = (poolPosY[nodeId] * pm + y * m) / newMass;
        poolPosZ[nodeId] = (poolPosZ[nodeId] * pm + z * m) / newMass;
    }
    poolMass[nodeId] = newMass;
    poolCount[nodeId]++; 
    if (depth > MAX_TREE_DEPTH) return;
    
    const idx3 = nodeId * 3;
    const minX = poolMin[idx3], minY = poolMin[idx3+1], minZ = poolMin[idx3+2];
    const maxX = poolMax[idx3], maxY = poolMax[idx3+1], maxZ = poolMax[idx3+2];
    
    const cx = (minX + maxX) * 0.5;
    const cy = (minY + maxY) * 0.5;
    const cz = (minZ + maxZ) * 0.5;

    let octant = 0;
    if (x >= cx) octant |= 1;
    if (y >= cy) octant |= 2;
    if (z >= cz) octant |= 4;

    let childId = poolNext[nodeId*8 + octant];

    if (childId === -1) {
        const nMinX = (octant & 1) ? cx : minX;
        const nMaxX = (octant & 1) ? maxX : cx;
        const nMinY = (octant & 2) ? cy : minY;
        const nMaxY = (octant & 2) ? maxY : cy;
        const nMinZ = (octant & 4) ? cz : minZ;
        const nMaxZ = (octant & 4) ? maxZ : cz;

        childId = allocNode(nMinX, nMinY, nMinZ, nMaxX, nMaxY, nMaxZ);
        if (childId !== -1) {
            poolNext[nodeId*8 + octant] = childId;
            poolPosX[childId] = x; poolPosY[childId] = y; poolPosZ[childId] = z; 
            poolMass[childId] = m; poolCount[childId] = 1;
        }
    } else {
        insertParticle(childId, x, y, z, m, depth + 1);
    }
}

function flattenAndSerialize(nodeId) {
    const myIndex = gpuSerialIndex++;
    const idx4 = myIndex * 4;
    treeDataPosMass[idx4+0] = poolPosX[nodeId];
    treeDataPosMass[idx4+1] = poolPosY[nodeId];
    treeDataPosMass[idx4+2] = poolPosZ[nodeId];
    treeDataPosMass[idx4+3] = poolMass[nodeId];

    const idx3 = nodeId * 3;
    const size = Math.max(poolMax[idx3] - poolMin[idx3], Math.max(poolMax[idx3+1] - poolMin[idx3+1], poolMax[idx3+2] - poolMin[idx3+2]));
    treeDataInfo[idx4+2] = size;

    let hasChildren = false;
    const nodeBase = nodeId * 8;
    for(let i=0; i<8; i++) {
        if (poolNext[nodeBase+i] !== -1) { hasChildren = true; break; }
    }

    if (hasChildren) {
        for(let i=0; i<8; i++) {
            const childId = poolNext[nodeBase+i];
            if (childId !== -1) flattenAndSerialize(childId);
        }
    }

    treeDataInfo[idx4+0] = hasChildren ? (myIndex + 1) : -1.0;
    treeDataInfo[idx4+1] = gpuSerialIndex;
}

function updateTreeTexture() {
    gpuSerialIndex = 0;
    flattenAndSerialize(0);
    document.getElementById('nodeDisplay').innerText = gpuSerialIndex;
    texTreePos.image.data = treeDataPosMass; texTreePos.needsUpdate = true;
    texTreeInfo.image.data = treeDataInfo; texTreeInfo.needsUpdate = true;
}

// --- THREE.JS SETUP ---
let renderer, scene, camera, controls, composer;
let texTreePos, texTreeInfo;
let positions, velocities;
let simScene, simCam, quad;
let points, matPoints, geom;

const vs = `varying vec2 vUv; void main() { vUv = uv; gl_Position = vec4(position, 1.0); }`;

const fsUpdate = `
    uniform sampler2D tPos; 
    uniform sampler2D tVel; 
    uniform sampler2D tTreePos;
    uniform sampler2D tTreeInfo;
    uniform float dt;
    uniform float theta;
    uniform float G;
    uniform float softening;
    uniform vec2 treeTexDim;
    varying vec2 vUv;
    
    void main() {
        vec4 posData = texture2D(tPos, vUv);
        vec3 myPos = posData.xyz;
        vec3 myVel = texture2D(tVel, vUv).xyz;
        float myMass = posData.w;

        vec3 acc = vec3(0.0);
        float idx = 0.0;
        
        for(int i = 0; i < 512; i++) { 
            vec2 uvNode = (vec2(mod(idx, treeTexDim.x), floor(idx / treeTexDim.x)) + 0.5) / treeTexDim;
            vec4 nPosMass = texture2D(tTreePos, uvNode);
            vec4 nInfo = texture2D(tTreeInfo, uvNode);
            
            vec3 nCom = nPosMass.xyz;
            float nMass = nPosMass.w;
            float childPtr = nInfo.x;
            float skipPtr = nInfo.y;
            float nSize = nInfo.z;

            vec3 dir = nCom - myPos;
            float distSq = dot(dir, dir);
            float dist = sqrt(distSq);
            
            bool isLeaf = childPtr < -0.5;
            bool farEnough = (nSize / dist) < theta;
            
            if (isLeaf || farEnough) {
                if (dist > 0.1) {
                    float f = (G * nMass) / pow(distSq + softening*softening, 1.5);
                    acc += dir * f;
                }
                idx = skipPtr;
            } else {
                idx = childPtr;
            }
            if (idx >= treeTexDim.x * treeTexDim.y) break;
        }

        // Slight drag to prevent explosion, but allow orbits
        myVel *= 0.9995; 
        myVel += acc * dt;
        gl_FragColor = vec4(myVel, 1.0);
    }
`;

const fsPosUpdate = `
    uniform sampler2D tPos;
    uniform sampler2D tVel;
    uniform float dt;
    varying vec2 vUv;
    void main() {
        vec4 p = texture2D(tPos, vUv);
        vec3 v = texture2D(tVel, vUv).xyz;
        p.xyz += v * dt;
        gl_FragColor = p;
    }
`;

const vsParticles = `
    uniform sampler2D tPos;
    varying float vMass; 
    void main() {
        vec4 p = texture2D(tPos, position.xy);
        vMass = p.w;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(p.xyz, 1.0);
        float dist = gl_Position.z;
        // Adjusted size to be less overwhelming
        gl_PointSize = (500.0 / dist) * (0.4 + p.w * 0.4);
    }
`;

const fsParticles = `
    varying float vMass;
    void main() { 
        vec2 coord = gl_PointCoord - vec2(0.5);
        float d = length(coord) * 2.0;
        if(d > 1.0) discard;
        
        float alpha = exp(-d * d * 3.0);

        // Realistic palette
        vec3 coldColor = vec3(0.05, 0.2, 0.6); // Darker blue
        vec3 midColor = vec3(0.2, 0.5, 0.9);   // Filament blue
        vec3 hotColor = vec3(1.0, 0.9, 0.6);   // Core white/yellow

        // Normal particles mass ~1.0, Black holes ~1000.0
        // We need to clamp this intelligently so black holes glow hot white
        float massNorm = clamp((vMass - 1.0) / 4.0, 0.0, 1.0);
        
        // Special override for super massive objects
        if (vMass > 100.0) {
            massNorm = 1.5; // Trigger bright white/orange
        }
        
        vec3 finalColor;
        if (massNorm < 0.5) {
            finalColor = mix(coldColor, midColor, massNorm * 2.0);
        } else {
            finalColor = mix(midColor, hotColor, clamp((massNorm - 0.5) * 2.0, 0.0, 1.0));
        }

        gl_FragColor = vec4(finalColor * 1.5, alpha); 
    }
`;

let fboPos1, fboPos2, fboVel1, fboVel2;
let matVelUpdate, matPosUpdate;
let readBuffer; 

// --- NEW SPAWNING LOGIC: CUBE WITH BLACK HOLES ---
async function generateParticles() {
    positions = new Float32Array(COUNT * 4);
    velocities = new Float32Array(COUNT * 4);
    readBuffer = new Float32Array(TEXTURE_WIDTH * TEXTURE_WIDTH * 4);

    const loadingProgress = document.getElementById('loadingProgress');
    loadingProgress.textContent = 'Generating Cube & Black Holes...';
    await new Promise(resolve => setTimeout(resolve, 10));

    const BATCH_SIZE = 5000;
    
    // CUBE DIMENSIONS
    const CUBE_SIZE = 1000.0; // Total width is 2x this
    const NUM_BLACK_HOLES = 12;

    // 1. Create Black Hole positions
    const blackHoles = [];
    for(let i=0; i<NUM_BLACK_HOLES; i++) {
        blackHoles.push({
            x: (Math.random() - 0.5) * 2 * CUBE_SIZE * 0.8, // Keep them somewhat inside
            y: (Math.random() - 0.5) * 2 * CUBE_SIZE * 0.8,
            z: (Math.random() - 0.5) * 2 * CUBE_SIZE * 0.8,
            mass: 800 + Math.random() * 800 // Very heavy
        });
    }

    for(let i=0; i<COUNT; i++) {
        let x, y, z, mass, vx, vy, vz;

        // The first few particles ARE the black holes
        if (i < NUM_BLACK_HOLES) {
            x = blackHoles[i].x;
            y = blackHoles[i].y;
            z = blackHoles[i].z;
            mass = blackHoles[i].mass;
            vx = (Math.random()-0.5) * 2.0; // Drifting slowly
            vy = (Math.random()-0.5) * 2.0;
            vz = (Math.random()-0.5) * 2.0;
        } else {
            // Random Cube Distribution
            x = (Math.random() - 0.5) * 2 * CUBE_SIZE;
            y = (Math.random() - 0.5) * 2 * CUBE_SIZE;
            z = (Math.random() - 0.5) * 2 * CUBE_SIZE;
            mass = 1.0 + Math.random() * 2.0;

            // VELOCITY LOGIC:
            // Find the nearest Black Hole and orbit it.
            // This creates "mini galaxies" inside the cube structure.
            
            let nearestBH = blackHoles[0];
            let minDistSq = Infinity;
            
            for(let bh of blackHoles) {
                const dx = x - bh.x;
                const dy = y - bh.y;
                const dz = z - bh.z;
                const dSq = dx*dx + dy*dy + dz*dz;
                if (dSq < minDistSq) {
                    minDistSq = dSq;
                    nearestBH = bh;
                }
            }
            
            const dist = Math.sqrt(minDistSq);
            
            // Vector pointing to BH
            const toBH = new THREE.Vector3(nearestBH.x - x, nearestBH.y - y, nearestBH.z - z).normalize();
            
            // Random axis for orbit plane
            const up = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            
            // Tangent vector (orbit direction)
            const tangent = new THREE.Vector3().crossVectors(toBH, up).normalize();
            
            // Orbital Speed = sqrt(G * M / r)
            // G is effectively built into our gravity constant, but we need rough stability
            const orbitSpeed = Math.sqrt(1500.0 / (dist + 10.0)); // Tuned for visuals
            
            // Apply velocity + velocity of the BH itself
            // Also add a little random noise
            vx = tangent.x * orbitSpeed; 
            vy = tangent.y * orbitSpeed;
            vz = tangent.z * orbitSpeed;
        }
        
        positions[i*4] = x;
        positions[i*4+1] = y;
        positions[i*4+2] = z;
        positions[i*4+3] = mass;

        velocities[i*4] = vx;
        velocities[i*4+1] = vy;
        velocities[i*4+2] = vz;

        if (i % BATCH_SIZE === 0 || i === COUNT - 1) {
            const progress = Math.floor(((i + 1) / COUNT) * 100);
            loadingProgress.textContent = `Spawning Cube... ${progress}%`;
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }
}

async function resetSimulation() {
    const loadingScreen = document.getElementById('loadingScreen');
    const loadingProgress = document.getElementById('loadingProgress');
    loadingScreen.classList.remove('hidden');
    
    await generateParticles();
    
    const tPos = new THREE.DataTexture(positions, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    const tVel = new THREE.DataTexture(velocities, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    tPos.needsUpdate = true; tVel.needsUpdate = true;
    
    if (fboPos1) fboPos1.dispose(); if (fboPos2) fboPos2.dispose();
    if (fboVel1) fboVel1.dispose(); if (fboVel2) fboVel2.dispose();
    
    fboPos1 = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_WIDTH, { type: THREE.FloatType });
    fboPos2 = fboPos1.clone();
    fboVel1 = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_WIDTH, { type: THREE.FloatType });
    fboVel2 = fboVel1.clone();

    if (quad) {
        quad.material.map = tPos;
    } else {
        simScene = new THREE.Scene();
        simCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({map: tPos}));
        simScene.add(quad);
    }
    
    renderer.setRenderTarget(fboPos1); renderer.render(simScene, simCam);
    quad.material.map = tVel;
    renderer.setRenderTarget(fboVel1); renderer.render(simScene, simCam);

    if (geom) geom.dispose();
    geom = new THREE.BufferGeometry();
    const uvArr = new Float32Array(COUNT * 3);
    for(let i=0; i<COUNT; i++) {
        uvArr[i*3] = (i % TEXTURE_WIDTH) / TEXTURE_WIDTH + (0.5/TEXTURE_WIDTH);
        uvArr[i*3+1] = Math.floor(i / TEXTURE_WIDTH) / TEXTURE_WIDTH + (0.5/TEXTURE_WIDTH);
    }
    geom.setAttribute('position', new THREE.BufferAttribute(uvArr, 3));

    if (matPoints) matPoints.dispose();
    matPoints = new THREE.ShaderMaterial({
        uniforms: { tPos: { value: fboPos1.texture } },
        vertexShader: vsParticles,
        fragmentShader: fsParticles,
        depthTest: false, blending: THREE.AdditiveBlending, transparent: true
    });
    
    if (points) {
        scene.remove(points);
        points.geometry.dispose();
        points.material.dispose();
    }
    points = new THREE.Points(geom, matPoints);
    points.frustumCulled = false;
    scene.add(points);
    
    document.getElementById('countDisplay').innerText = COUNT;
    
    // Populate pool arrays from newly generated positions for tree building
    for(let i=0; i<COUNT; i++) {
        const i4 = i*4;
        poolPosX[i] = positions[i4];
        poolPosY[i] = positions[i4+1];
        poolPosZ[i] = positions[i4+2];
        poolMass[i] = positions[i4+3];
    }
    
    // Rebuild the tree with new particle data
    buildTree();
    
    loadingProgress.textContent = 'Complete!';
    await new Promise(resolve => setTimeout(resolve, 200));
    loadingScreen.classList.add('hidden');
}

async function init() {
    // --- UI INIT ---
    const bind = (id, fn) => {
        const el = document.getElementById(id);
        if(el) el.addEventListener('input', fn);
    };

    bind('thetaSlider', e => { 
        THETA = parseFloat(e.target.value); 
        if(matVelUpdate) matVelUpdate.uniforms.theta.value = THETA; 
    });
    
    bind('speedSlider', e => { 
        const val = parseFloat(e.target.value);
        TIME_STEP = val * BASE_DT;
        document.getElementById('speedValue').innerText = val.toFixed(1) + 'x';
    });
    
    bind('treeRateSlider', e => { TREE_UPDATE_INTERVAL = parseInt(e.target.value); });
    
    const particleCountSlider = document.getElementById('particleCountSlider');
    const particleCountValue = document.getElementById('particleCountValue');
    bind('particleCountSlider', e => {
        const newCount = parseInt(e.target.value);
        particleCountValue.textContent = newCount;
    });

    document.getElementById('resetBtn').addEventListener('click', async () => {
        isResetting = true; 
        const newCount = parseInt(particleCountSlider.value);
        if (newCount !== COUNT) {
            COUNT = newCount;
            TEXTURE_WIDTH = getTextureWidth(COUNT);
            MAX_NODES = COUNT * 2;
        }
        await resetSimulation();
        isResetting = false; 
    });

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", logarithmicDepthBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(new THREE.Color(0x010103));
    document.body.appendChild(renderer.domElement);
    
    if (!renderer.capabilities.isWebGL2 && !renderer.extensions.get('OES_texture_float')) {
        alert("Requires Float Texture support"); return;
    }

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 20000);
    // Move further back to see the giant cube
    camera.position.set(0, 500, 1800);
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true; 
    controls.autoRotateSpeed = 0.5; 
    controls.maxDistance = 15000;

    composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.2, 0.1);
    composer.addPass(bloomPass);

    window.addEventListener('resize', () => {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);
    });

    const loadingScreen = document.getElementById('loadingScreen');
    const loadingProgress = document.getElementById('loadingProgress');
    
    await generateParticles();

    const tPos = new THREE.DataTexture(positions, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    const tVel = new THREE.DataTexture(velocities, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    tPos.needsUpdate = true; tVel.needsUpdate = true;
    
    texTreePos = new THREE.DataTexture(treeDataPosMass, NODE_TEX_WIDTH, NODE_TEX_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    texTreeInfo = new THREE.DataTexture(treeDataInfo, NODE_TEX_WIDTH, NODE_TEX_WIDTH, THREE.RGBAFormat, THREE.FloatType);
    
    fboPos1 = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_WIDTH, { type: THREE.FloatType });
    fboPos2 = fboPos1.clone();
    fboVel1 = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_WIDTH, { type: THREE.FloatType });
    fboVel2 = fboVel1.clone();

    simScene = new THREE.Scene();
    simCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
    quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({map: tPos}));
    simScene.add(quad);
    
    renderer.setRenderTarget(fboPos1); renderer.render(simScene, simCam);
    quad.material.map = tVel;
    renderer.setRenderTarget(fboVel1); renderer.render(simScene, simCam);

    matVelUpdate = new THREE.ShaderMaterial({
        uniforms: {
            tPos: { value: null }, tVel: { value: null }, tTreePos: { value: texTreePos }, tTreeInfo: { value: texTreeInfo },
            dt: { value: TIME_STEP }, theta: { value: THETA }, G: { value: GRAVITY }, softening: { value: SOFTENING },
            treeTexDim: { value: new THREE.Vector2(NODE_TEX_WIDTH, NODE_TEX_WIDTH) }
        },
        vertexShader: vs, fragmentShader: fsUpdate
    });

    matPosUpdate = new THREE.ShaderMaterial({
        uniforms: { tPos: { value: null }, tVel: { value: null }, dt: { value: TIME_STEP } },
        vertexShader: vs, fragmentShader: fsPosUpdate
    });

    geom = new THREE.BufferGeometry();
    const uvArr = new Float32Array(COUNT * 3);
    for(let i=0; i<COUNT; i++) {
        uvArr[i*3] = (i % TEXTURE_WIDTH) / TEXTURE_WIDTH + (0.5/TEXTURE_WIDTH);
        uvArr[i*3+1] = Math.floor(i / TEXTURE_WIDTH) / TEXTURE_WIDTH + (0.5/TEXTURE_WIDTH);
    }
    geom.setAttribute('position', new THREE.BufferAttribute(uvArr, 3));

    matPoints = new THREE.ShaderMaterial({
        uniforms: { tPos: { value: fboPos1.texture } },
        vertexShader: vsParticles,
        fragmentShader: fsParticles,
        depthTest: false, blending: THREE.AdditiveBlending, transparent: true
    });
    
    points = new THREE.Points(geom, matPoints);
    points.frustumCulled = false; 
    scene.add(points);

    document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    
    loadingProgress.textContent = 'Complete!';
    await new Promise(resolve => setTimeout(resolve, 200));
    loadingScreen.classList.add('hidden');
    
    animate();
}

function buildTree() {
    resetPool();
    let minX=1e9, minY=1e9, minZ=1e9, maxX=-1e9, maxY=-1e9, maxZ=-1e9;
    
    for(let i=0; i<COUNT; i++) {
        const x = poolPosX[i], y = poolPosY[i], z = poolPosZ[i];
        if(x<minX) minX=x; if(x>maxX) maxX=x;
        if(y<minY) minY=y; if(y>maxY) maxY=y;
        if(z<minZ) minZ=z; if(z>maxZ) maxZ=z;
    }
    
    const midX = (minX+maxX)*0.5, midY = (minY+maxY)*0.5, midZ = (minZ+maxZ)*0.5;
    const maxDim = Math.max(maxX-minX, maxY-minY, maxZ-minZ) * 1.05;
    const half = maxDim * 0.5;
    
    const root = allocNode(midX-half, midY-half, midZ-half, midX+half, midY+half, midZ+half);
    for(let i=0; i<COUNT; i++) insertParticle(root, poolPosX[i], poolPosY[i], poolPosZ[i], poolMass[i], 0);
    updateTreeTexture();
}

const keys = {};
const moveSpeed = 300.0;
function updateCamera(dt) {
    if (!keys['w'] && !keys['s'] && !keys['a'] && !keys['d'] && !keys['q'] && !keys['e']) return;
    controls.autoRotate = false; 
    const dir = new THREE.Vector3();
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    const rgt = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
    const up = new THREE.Vector3(0,1,0);
    
    if (keys['w']) dir.add(fwd);
    if (keys['s']) dir.sub(fwd);
    if (keys['a']) dir.sub(rgt);
    if (keys['d']) dir.add(rgt);
    if (keys['e']) dir.add(up);
    if (keys['q']) dir.sub(up);
    
    if (dir.lengthSq() > 0) {
        const speedMultiplier = keys['shift'] ? 10.0 : 1.0;
        dir.normalize().multiplyScalar(moveSpeed * speedMultiplier * dt);
        camera.position.add(dir);
        controls.target.add(dir);
    }
}

let frameCount = 0;
let lastTime = 0;
let isResetting = false; 

function calculateMassCenter() {
    let totalMass = 0;
    let comX = 0, comY = 0, comZ = 0;
    for(let i = 0; i < COUNT; i++) {
        const mass = poolMass[i];
        if (mass > 0) {
            totalMass += mass;
            comX += poolPosX[i] * mass;
            comY += poolPosY[i] * mass;
            comZ += poolPosZ[i] * mass;
        }
    }
    if (totalMass > 0) {
        return new THREE.Vector3(comX / totalMass, comY / totalMass, comZ / totalMass);
    }
    return new THREE.Vector3(0, 0, 0);
}

function animate(time) {
    requestAnimationFrame(animate);
    if (isResetting) return;

    const dtSeconds = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;
    if(frameCount % 20 === 0) document.getElementById('fpsDisplay').innerText = Math.round(1/dtSeconds);

    const massCenter = calculateMassCenter();
    const currentOffset = new THREE.Vector3().subVectors(camera.position, controls.target);
    controls.target.copy(massCenter);
    camera.position.copy(massCenter).add(currentOffset);
    
    updateCamera(dtSeconds);
    controls.update();

    if (TIME_STEP > 0) {
        if (frameCount % TREE_UPDATE_INTERVAL === 0) {
            renderer.readRenderTargetPixels(fboPos1, 0, 0, TEXTURE_WIDTH, TEXTURE_WIDTH, readBuffer);
            for(let i=0; i<COUNT; i++) {
                const i4 = i*4;
                poolPosX[i] = readBuffer[i4]; poolPosY[i] = readBuffer[i4+1]; poolPosZ[i] = readBuffer[i4+2]; poolMass[i] = readBuffer[i4+3]; 
            }
            buildTree();
        }

        quad.material = matVelUpdate;
        matVelUpdate.uniforms.tPos.value = fboPos1.texture;
        matVelUpdate.uniforms.tVel.value = fboVel1.texture;
        matVelUpdate.uniforms.dt.value = TIME_STEP;
        renderer.setRenderTarget(fboVel2); renderer.render(simScene, simCam);
        
        let temp = fboVel1; fboVel1 = fboVel2; fboVel2 = temp;
        
        quad.material = matPosUpdate;
        matPosUpdate.uniforms.tPos.value = fboPos1.texture;
        matPosUpdate.uniforms.tVel.value = fboVel1.texture; 
        matPosUpdate.uniforms.dt.value = TIME_STEP;
        renderer.setRenderTarget(fboPos2); renderer.render(simScene, simCam);
        
        temp = fboPos1; fboPos1 = fboPos2; fboPos2 = temp;
    }

    scene.children[0].material.uniforms.tPos.value = fboPos1.texture;
    composer.render();
    frameCount++;
}

init();
</script>
</body>
</html>