<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU N-Body Gravity</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #eee;
            background: rgba(10, 10, 10, 0.85);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            backdrop-filter: blur(8px);
            user-select: none;
            max-width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            transition: opacity 0.3s, transform 0.3s;
        }

        #ui.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-20px);
        }

        #uiToggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid #333;
            color: #00d2ff;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(8px);
            transition: all 0.2s;
            z-index: 1000;
            width: auto;
            margin-top: 0;
        }

        #uiToggle:hover {
            background: #333;
            border-color: #00d2ff;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.1rem; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px; }
        h2 { margin: 0 0 15px 0; font-size: 0.8rem; color: #888; font-weight: normal; }
        p { font-size: 0.85rem; color: #bbb; margin-bottom: 15px; line-height: 1.4; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 0.8rem; color: #888; margin-bottom: 5px; }
        .stat-val { color: #fff; font-family: monospace; }

        button {
            background: #222;
            border: 1px solid #444;
            color: #00d2ff;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            width: 100%;
            margin-top: 10px;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 1px;
        }
        button:hover { background: #333; border-color: #00d2ff; }
        button:active { background: #00d2ff; color: #000; }

        .slider-group { margin-top: 15px; }
        label { display: block; font-size: 0.75rem; margin-bottom: 5px; color: #aaa; }
        input[type="range"] { width: 100%; accent-color: #00d2ff; }
        select {
            width: 100%;
            padding: 8px 10px;
            background: #111;
            color: #eee;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
        }
        select:focus {
            outline: none;
            border-color: #00d2ff;
        }
        #ui .slider-group label { display: flex; justify-content: space-between; align-items: center; }
        #speedDisplay { font-family: monospace; color: #fff; }

        #warning {
            color: #ffaa00;
            font-size: 0.7rem;
            margin-top: 10px;
            display: none;
        }

        /* Modal for adding particles */
        #particleModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        #particleModal.active {
            display: flex;
        }

        .modal-content {
            background: rgba(10, 10, 10, 0.95);
            border: 1px solid #00d2ff;
            border-radius: 8px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 20px rgba(0, 210, 255, 0.3);
        }

        .modal-content h3 {
            margin: 0 0 20px 0;
            color: #00d2ff;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .modal-content label {
            display: block;
            color: #aaa;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .modal-content input[type="number"] {
            width: 100%;
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 1rem;
            box-sizing: border-box;
            margin-bottom: 20px;
        }

        .modal-content input[type="number"]:focus {
            outline: none;
            border-color: #00d2ff;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-buttons button {
            flex: 1;
            margin-top: 0;
        }

        /* Settings modal */
        #settingsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1001;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }

        #settingsModal.active {
            display: flex;
        }

        .modal-content.settings {
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content .slider-group {
            margin-bottom: 20px;
        }

        .modal-content input[type="range"] {
            width: 100%;
            accent-color: #00d2ff;
            margin-bottom: 5px;
        }

        .modal-content .value-display {
            color: #00d2ff;
            font-family: monospace;
            font-size: 0.9rem;
            text-align: right;
            margin-top: 5px;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .toggle-group label {
            margin-bottom: 0;
            flex: 1;
        }

        .toggle-group.disabled label {
            color: #555;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
            background: #333;
            border-radius: 12px;
            border: 1px solid #444;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: #00d2ff;
            border-color: #00d2ff;
        }

        .toggle-switch.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #fff;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .toggle-switch.active::after {
            left: 28px;
        }
    </style>
    
    <!-- Import Map for Modular Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="ui">
    <h1>GPU Gravity Engine</h1>
    <h2>N-Body Particle Simulation</h2>
    
    <div class="stat-row">
        <span>Particles:</span>
        <span class="stat-val" id="particlesVal">4096</span>
    </div>
    <div class="stat-row">
        <span>Calculations/Frame:</span>
        <span class="stat-val" id="calcVal">~16.78 M</span>
    </div>
    <div class="stat-row">
        <span>FPS:</span>
        <span class="stat-val" id="fpsVal">--</span>
    </div>
    <div class="stat-row">
        <span>Sim Time:</span>
        <span class="stat-val" id="simTimeVal">0.0s</span>
    </div>

    <div class="slider-group">
        <label>Time Speed <span class="stat-val" id="speedDisplay">1.0x</span></label>
        <input type="range" id="speedRange" min="0" max="2" step="0.1" value="1">
    </div>

    <div class="slider-group">
        <label>Simulation</label>
        <select id="simulationSelect">
            <option value="disk">Disk</option>
            <option value="web">Universe Web</option>
        </select>
    </div>

    <div class="toggle-group">
        <label>Show Grid</label>
        <div class="toggle-switch" id="gridToggle"></div>
    </div>

    <button id="settingsBtn">Settings</button>
    <button id="resetCameraBtn">Reset Camera</button>
    <button id="resetBtn">Reset Simulation</button>
    <div id="warning">Hardware acceleration required.</div>
</div>

<button id="uiToggle">Hide UI</button>

<!-- Modal for adding particles -->
<div id="particleModal">
    <div class="modal-content">
        <h3>Add Particle</h3>
        <label for="particleMass">Mass:</label>
        <input type="number" id="particleMass" min="0.1" step="0.1" value="1.0">
        <div class="modal-buttons">
            <button id="addParticleBtn">Add</button>
            <button id="cancelParticleBtn">Cancel</button>
        </div>
    </div>
</div>

<!-- Settings Modal -->
<div id="settingsModal">
    <div class="modal-content settings">
        <h3>Simulation Settings</h3>
        
        <div class="slider-group">
            <label>Time Speed: <span class="value-display" id="speedValue">1.0</span></label>
            <input type="range" id="settingsSpeed" min="0" max="2" step="0.1" value="1">
        </div>

        <div class="slider-group">
            <label>Gravity Constant (G): <span class="value-display" id="gravityValue">3.2</span></label>
            <input type="range" id="settingsGravity" min="0.1" max="10" step="0.1" value="3.2">
        </div>

        <div class="slider-group">
            <label>Softening: <span class="value-display" id="softeningValue">2.5</span></label>
            <input type="range" id="settingsSoftening" min="0.1" max="20" step="0.5" value="2.5">
        </div>

        <div class="slider-group">
            <label>Damping: <span class="value-display" id="dampingValue">0.9995</span></label>
            <input type="range" id="settingsDamping" min="0.99" max="1.0" step="0.0001" value="0.9995">
        </div>

        <div class="slider-group">
            <label>Max Velocity: <span class="value-display" id="maxVelValue">120.0</span></label>
            <input type="range" id="settingsMaxVel" min="10" max="200" step="5" value="120.0">
        </div>

        <div class="slider-group">
            <label>Bounds: <span class="value-display" id="boundsValue">2000</span></label>
            <input type="range" id="settingsBounds" min="500" max="5000" step="100" value="2000">
        </div>

        <div class="slider-group">
            <label>Particle Size Multiplier: <span class="value-display" id="particleSizeValue">5.5</span></label>
            <input type="range" id="settingsParticleSize" min="1" max="20" step="0.5" value="5.5">
        </div>

        <div class="modal-buttons">
            <button id="saveSettingsBtn">Save</button>
            <button id="cancelSettingsBtn">Cancel</button>
        </div>
    </div>
</div>

<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Configuration ---
    const TARGET_STEP = 1 / 60;
    const MAX_SUBSTEPS = 4;
    const SIMULATION_MODES = {
        disk: {
            label: 'Disk',
            textureWidth: 64,
            gridVisible: true,
            gridEnabled: true,
            camera: { x: 0, y: 100, z: 250 }
        },
        web: {
            label: 'Universe Web',
            textureWidth: 128,
            gridVisible: false,
            gridEnabled: false,
            camera: { x: 0, y: 220, z: 820 }
        }
    };
    const DISK_SETTINGS = {
        radius: 520,
        height: 110,
        arms: 3,
        tightness: 0.28,
        centralMass: 1800
    };
    const WEB_SETTINGS = {
        radius: 900,
        thickness: 140,
        hubCount: 8,
        hubMassMin: 18,
        hubMassMax: 65
    };
    const GALAXY_RADIUS = DISK_SETTINGS.radius;
    const GALAXY_HEIGHT = DISK_SETTINGS.height;
    const GALAXY_ARMS = DISK_SETTINGS.arms;
    const GALAXY_TIGHTNESS = DISK_SETTINGS.tightness;
    const CENTRAL_MASS = DISK_SETTINGS.centralMass;
    const WEB_RADIUS = WEB_SETTINGS.radius;
    const WEB_THICKNESS = WEB_SETTINGS.thickness;
    const HUB_COUNT = WEB_SETTINGS.hubCount;
    const HUB_MASS_MIN = WEB_SETTINGS.hubMassMin;
    const HUB_MASS_MAX = WEB_SETTINGS.hubMassMax;

    let simulationMode = 'disk';
    let TEXTURE_WIDTH = SIMULATION_MODES[simulationMode].textureWidth;
    let PARTICLES = TEXTURE_WIDTH * TEXTURE_WIDTH;
    
    // --- Configurable Parameters ---
    let BOUNDS = 2000;
    let BOUNDS_HALF = BOUNDS / 2;
    let GRAVITY_CONSTANT = 3.2;
    let SOFTENING = 2.5;
    let DAMPING = 0.9995;
    let MAX_VELOCITY = 120.0;
    let PARTICLE_SIZE_MULT = 5.5;
    let gridVisible = SIMULATION_MODES[simulationMode].gridVisible;
    let gridEnabled = SIMULATION_MODES[simulationMode].gridEnabled;
    let cameraDefaults = { ...SIMULATION_MODES[simulationMode].camera };

    let CORE_PARTICLES = Math.max(12, Math.floor(PARTICLES * 0.01));
    let HUB_CORE_PARTICLES = Math.max(18, Math.floor(PARTICLES * 0.03));
    let FILAMENT_PARTICLES = Math.floor(PARTICLES * 0.62);
    let VOID_PARTICLES = PARTICLES - HUB_CORE_PARTICLES - FILAMENT_PARTICLES;
    const GRID_LIGHT_DIR = new THREE.Vector3(0.45, 0.78, 0.4).normalize();
    const GRID_LIGHT_COLOR = new THREE.Color(0xfff4dd);

    // --- State ---
    let scene, camera, renderer, controls;
    let speed = 1.0;
    let simTime = 0;
    let lastFrameTime = 0;
    let lastFpsSample = 0;
    let frameCounter = 0;
    let uiStats = {};
    let webHubs = [];
    
    // Keyboard movement state
    const keys = {};
    const moveSpeed = 5.0; // Movement speed per frame

    // --- GPU Compute Variables ---
    let gpuCompute;
    let velocityVariable;
    let positionVariable;
    let positionUniforms;
    let velocityUniforms;
    
    // Custom FBO helper since GPUComputationRenderer is hard to bundle in one file cleanly without full imports
    // We will implement a raw Double-Buffer FBO approach
    let sceneFBO, cameraFBO;
    let rtPosition1, rtPosition2;
    let rtVelocity1, rtVelocity2;
    let geometryFBO;
    let meshPos, meshVel;
    let matPos, matVel;

    // Visuals
    let particleMesh, gridMesh;
    let particleUniforms, gridUniforms;
    let materialParticles;
    let particleMasses;

    // GPU-side single-texel update helper (avoid CPU readPixels roundtrip)
    let sceneInject, meshInject, matInject;

    // --- Shaders ---

    // 1. Vertex Shader (Pass-through for FBO quad)
    const vsFBO = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    `;

    // 2. Position Fragment Shader (Integrator)
    function getFsPosition() {
        return `
        uniform sampler2D texPos;
        uniform sampler2D texVel;
        uniform float delta;
        uniform float bounds;
        uniform float boundsHalf;
        varying vec2 vUv;

        void main() {
            vec4 pos = texture2D( texPos, vUv );
            vec4 vel = texture2D( texVel, vUv );
            
            // Update Position: p = p + v * dt
            pos.xyz += vel.xyz * delta;
            
            // Keep particles within bounds (soft boundary)
            // Clamp to bounds to prevent particles from disappearing
            pos.x = clamp(pos.x, -boundsHalf, boundsHalf);
            pos.y = clamp(pos.y, -boundsHalf, boundsHalf);
            pos.z = clamp(pos.z, -boundsHalf, boundsHalf);
            
            gl_FragColor = pos;
        }
    `;
    }

    // 3. Velocity Fragment Shader (Gravity Physics - The Heavy Lifter)
    function getFsVelocity(widthValue) {
        return `
        uniform sampler2D texPos;
        uniform sampler2D texVel;
        uniform float delta;
        uniform float time;
        uniform float gravityConstant;
        uniform float softening;
        uniform float damping;
        uniform float maxVelocity;
        varying vec2 vUv;

        const float width = ${widthValue.toFixed(1)};
        const float count = width * width;

        void main() {
            vec4 myPos = texture2D( texPos, vUv );
            vec4 myVel = texture2D( texVel, vUv );
            
            vec3 acc = vec3(0.0);
            
            // Loop through ALL other particles
            // In a fragment shader, this loop runs in parallel for every pixel
            for (float y = 0.0; y < width; y++) {
                for (float x = 0.0; x < width; x++) {
                    
                    vec2 refUv = vec2(x + 0.5, y + 0.5) / width;
                    vec4 otherPos = texture2D( texPos, refUv );
                    
                    vec3 dir = otherPos.xyz - myPos.xyz;
                    float distSq = dot(dir, dir);
                    
                    // Skip self-interaction (when distance is very small)
                    if (distSq < 0.01) continue;
                    
                    // F = G * m1 * m2 / r^2
                    // a = F / m1 = G * m2 / r^2
                    // We store mass in the w component of position
                    
                    float f = (gravityConstant * otherPos.w) / (distSq + softening);
                    float dist = sqrt(distSq);
                    
                    // Safe normalize - avoid division by zero
                    acc += (dir / dist) * f;
                }
            }

            // Apply acceleration
            myVel.xyz += acc * delta;
            
            // Damping to prevent system from exploding
            myVel.xyz *= damping;
            
            // Limit maximum velocity to prevent particles from moving too fast
            float velMag = length(myVel.xyz);
            if (velMag > maxVelocity) {
                myVel.xyz = normalize(myVel.xyz) * maxVelocity;
            }

            gl_FragColor = myVel;
        }
    `;
    }

    // 4. Particle Vertex Shader (Visuals)
    const vsParticles = `
        uniform sampler2D texPos;
        uniform float particleSizeMult;
        varying vec3 vColor;
        varying float vLum;
        varying float vSeed;

        void main() {
            // Read position from texture based on uv coordinate
            // We use the 'position' attribute of the buffer geometry as the UV lookup
            vec2 uv = position.xy;
            vec4 posData = texture2D( texPos, uv );

            vec3 pos = posData.xyz;
            float mass = max(posData.w, 0.6);

            // Stable per-particle seed from UVs
            vSeed = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);

            float massNorm = clamp((mass - 0.8) / 7.5, 0.0, 1.0);
            float warmBlend = smoothstep(0.0, 0.55, massNorm);
            float blueBlend = smoothstep(0.6, 1.0, massNorm);

            vec3 warmColor = vec3(1.0, 0.76, 0.52);
            vec3 whiteColor = vec3(1.0, 0.95, 0.88);
            vec3 blueColor = vec3(0.62, 0.8, 1.0);

            vec3 baseColor = mix(warmColor, whiteColor, warmBlend);
            baseColor = mix(baseColor, blueColor, blueBlend);
            vColor = baseColor;

            vLum = clamp(pow(mass, 0.75), 0.9, 5.0);

            // Calculate View Position
            vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );
            gl_Position = projectionMatrix * mvPosition;

            // Size based on mass with softer falloff
            float depth = max(-mvPosition.z, 0.1);
            float sizeFactor = pow(mass, 0.6);
            gl_PointSize = particleSizeMult * sizeFactor * (400.0 / depth);
            gl_PointSize = clamp(gl_PointSize, 6.0, 190.0);
        }
    `;

    // 5. Particle Fragment Shader
    const fsParticles = `
        uniform float time;
        varying vec3 vColor;
        varying float vLum;
        varying float vSeed;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;

            float dist = sqrt(r);
            float core = exp(-dist * dist * 16.0);
            float halo = exp(-dist * dist * 4.0);

            float twinkleStrength = mix(0.14, 0.05, clamp(vLum / 3.5, 0.0, 1.0));
            float twinkle = 1.0 + twinkleStrength * sin(time * (2.5 + vSeed * 2.0) + vSeed * 12.0);

            vec3 coreColor = mix(vColor, vec3(1.0), 0.35);
            vec3 haloColor = vColor * 0.7;

            vec3 finalColor = (coreColor * core * 1.45 + haloColor * halo * 0.85) * vLum * twinkle * 1.3;
            float alpha = clamp(core * 1.15 + halo * 0.6, 0.0, 1.0);

            gl_FragColor = vec4(finalColor, alpha);
        }
    `;

    // 6. Grid Vertex Shader (Spacetime warping)
    function getVsGrid(widthValue) {
        return `
        uniform sampler2D texPos;
        varying float vDepth;
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        const float width = ${widthValue.toFixed(1)};

        void main() {
            vUv = uv;
            vec3 newPos = position;
            
            // Calculate potential at this grid vertex
            // We loop through particles again. 
            // Note: Doing this 1024 times per vertex for a high-res grid is heavy.
            // Modern GPUs can handle it, but we keep grid resolution reasonable.
            
            float potential = 0.0;
            
            for (float y = 0.0; y < width; y++) {
                for (float x = 0.0; x < width; x++) {
                    vec2 refUv = vec2(x + 0.5, y + 0.5) / width;
                    vec4 pPos = texture2D( texPos, refUv );
                    
                    float d = distance(newPos.xz, pPos.xz);
                    // Gravity Well formula
                    // z = - Sum( Mass / Distance )
                    potential -= (pPos.w * 8.0) / (d + 10.0);
                }
            }
            
            // Allow grid to go to very negative values (approaching -int64)
            // No cap - let it go as deep as needed
            vDepth = potential;
            newPos.y = potential;

            vec4 mvPosition = modelViewMatrix * vec4( newPos, 1.0 );
            vNormal = vec3(0.0, 1.0, 0.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    `;
    }

    // 7. Grid Fragment Shader
    const fsGrid = `
        uniform vec3 lightDir;
        uniform vec3 lightColor;
        uniform float ambientIntensity;
        varying float vDepth;
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        
        void main() {
            // Color based on depth (strain)
            vec3 colorFlat = vec3(0.1, 0.1, 0.15);
            vec3 colorDeep = vec3(0.0, 0.8, 1.0);
            
            float mixVal = smoothstep(0.0, -50.0, vDepth);
            vec3 baseColor = mix(colorFlat, colorDeep, mixVal);

            vec3 normal = normalize(vNormal);
            vec3 lightDirection = normalize(lightDir);
            float diff = max(dot(normal, lightDirection), 0.0);
            vec3 diffuse = lightColor * diff;
            vec3 ambient = vec3(0.08) + lightColor * ambientIntensity;
            vec3 viewDir = normalize(vViewPosition);
            vec3 reflectDir = reflect(-lightDirection, normal);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
            vec3 specular = vec3(1.0) * spec * 0.35;
            vec3 litColor = baseColor * (ambient + diffuse * 0.9) + specular;
            vec3 col = mix(baseColor, litColor, 0.65);
            
            // Grid lines
            // Simple analytical grid
            float scale = 160.0;
            vec2 grid = abs(fract(vUv * scale - 0.5) - 0.5) / fwidth(vUv * scale);
            float line = min(grid.x, grid.y);
            float lineAlpha = 1.0 - min(line, 1.0);

            if(lineAlpha < 0.1) discard;

            float alpha = clamp(0.35 * lineAlpha + mixVal * 0.12, 0.0, 0.55);
            gl_FragColor = vec4(col, alpha);
        }
    `;

    // Single-texel overwrite shader (used to inject a new particle into the simulation textures)
    const fsInjectTexel = `
        uniform sampler2D texIn;
        uniform vec2 targetCoord; // integer texel coord: (col, row)
        uniform vec4 newValue;
        varying vec2 vUv;

        void main() {
            vec4 current = texture2D(texIn, vUv);
            vec2 fragCoord = floor(gl_FragCoord.xy); // 0..width-1
            float isTarget = 1.0 - step(0.5, length(fragCoord - targetCoord));
            gl_FragColor = mix(current, newValue, isTarget);
        }
    `;

    function createGlowTexture(size = 128) {
        const canvas = document.createElement('canvas');
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(
            size / 2, size / 2, 0,
            size / 2, size / 2, size / 2
        );
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(0.08, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.22, 'rgba(255, 255, 255, 0.55)');
        gradient.addColorStop(0.55, 'rgba(160, 200, 255, 0.18)');
        gradient.addColorStop(1, 'rgba(120, 160, 255, 0.0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.needsUpdate = true;
        return texture;
    }

    function applySimulationMode(mode) {
        const config = SIMULATION_MODES[mode] || SIMULATION_MODES.disk;
        simulationMode = SIMULATION_MODES[mode] ? mode : 'disk';
        TEXTURE_WIDTH = config.textureWidth;
        PARTICLES = TEXTURE_WIDTH * TEXTURE_WIDTH;
        gridVisible = config.gridVisible;
        gridEnabled = config.gridEnabled;
        cameraDefaults = { ...config.camera };

        CORE_PARTICLES = Math.max(12, Math.floor(PARTICLES * 0.01));
        HUB_CORE_PARTICLES = Math.max(18, Math.floor(PARTICLES * 0.03));
        FILAMENT_PARTICLES = Math.floor(PARTICLES * 0.62);
        VOID_PARTICLES = PARTICLES - HUB_CORE_PARTICLES - FILAMENT_PARTICLES;
        webHubs = [];
    }

    function disposeMesh(mesh) {
        if (!mesh) return;
        if (scene) scene.remove(mesh);
        if (mesh.geometry) mesh.geometry.dispose();
        if (Array.isArray(mesh.material)) {
            mesh.material.forEach(material => material.dispose());
        } else if (mesh.material) {
            mesh.material.dispose();
        }
    }

    function cleanupSimulation() {
        disposeMesh(particleMesh);
        disposeMesh(gridMesh);
        particleMesh = null;
        gridMesh = null;
        gridUniforms = null;
        particleUniforms = null;

        if (geometryFBO) {
            geometryFBO.dispose();
            geometryFBO = null;
        }
        if (matPos) matPos.dispose();
        if (matVel) matVel.dispose();
        if (matInject) matInject.dispose();
        matPos = null;
        matVel = null;
        matInject = null;

        if (rtPosition1) rtPosition1.dispose();
        if (rtPosition2) rtPosition2.dispose();
        if (rtVelocity1) rtVelocity1.dispose();
        if (rtVelocity2) rtVelocity2.dispose();
        rtPosition1 = null;
        rtPosition2 = null;
        rtVelocity1 = null;
        rtVelocity2 = null;

        sceneFBO = null;
        sceneInject = null;
        meshPos = null;
        meshVel = null;
        meshInject = null;
    }

    function setupSimulation() {
        // --- FBO Setup (The GPU Computer) ---
        sceneFBO = new THREE.Scene();
        if (!cameraFBO) cameraFBO = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // Initial Data
        const initialPos = getInitialPositions();
        const initialVel = getInitialVelocities(initialPos);
        particleMasses = new Float32Array(PARTICLES);
        for (let i = 0; i < PARTICLES; i++) particleMasses[i] = initialPos[i * 4 + 3];

        // Render Targets (Double Buffered)
        rtPosition1 = createRenderTarget(initialPos);
        rtPosition2 = createRenderTarget(initialPos);
        rtVelocity1 = createRenderTarget(initialVel);
        rtVelocity2 = createRenderTarget(initialVel);

        // FBO Geometry (Full screen quad)
        geometryFBO = new THREE.PlaneGeometry(2, 2);

        // Simulation Materials
        matPos = new THREE.ShaderMaterial({
            uniforms: {
                texPos: { value: null },
                texVel: { value: null },
                delta: { value: 0.0 },
                bounds: { value: BOUNDS },
                boundsHalf: { value: BOUNDS_HALF }
            },
            vertexShader: vsFBO,
            fragmentShader: getFsPosition()
        });

        matVel = new THREE.ShaderMaterial({
            uniforms: {
                texPos: { value: null },
                texVel: { value: null },
                delta: { value: 0.0 },
                time: { value: 0.0 },
                gravityConstant: { value: GRAVITY_CONSTANT },
                softening: { value: SOFTENING },
                damping: { value: DAMPING },
                maxVelocity: { value: MAX_VELOCITY }
            },
            vertexShader: vsFBO,
            fragmentShader: getFsVelocity(TEXTURE_WIDTH)
        });

        meshPos = new THREE.Mesh(geometryFBO, matPos);
        meshVel = new THREE.Mesh(geometryFBO, matVel);
        sceneFBO.add(meshPos);
        sceneFBO.add(meshVel);

        // GPU-side inject (single texel overwrite) scene
        sceneInject = new THREE.Scene();
        matInject = new THREE.ShaderMaterial({
            uniforms: {
                texIn: { value: null },
                targetCoord: { value: new THREE.Vector2(0, 0) },
                newValue: { value: new THREE.Vector4(0, 0, 0, 0) }
            },
            vertexShader: vsFBO,
            fragmentShader: fsInjectTexel
        });
        meshInject = new THREE.Mesh(geometryFBO, matInject);
        sceneInject.add(meshInject);

        // --- Visual Scene Setup ---

        // 1. Particles System
        const particlesGeo = new THREE.BufferGeometry();
        const particleUvs = new Float32Array(PARTICLES * 3);
        
        for (let i = 0; i < PARTICLES; i++) {
            const col = i % TEXTURE_WIDTH;
            const row = Math.floor(i / TEXTURE_WIDTH);
            const x = (col + 0.5) / TEXTURE_WIDTH;
            const y = (row + 0.5) / TEXTURE_WIDTH;
            
            particleUvs[i * 3] = x;
            particleUvs[i * 3 + 1] = y;
            particleUvs[i * 3 + 2] = 0;
        }

        console.log("Sample UVs:", particleUvs[0], particleUvs[1], particleUvs[2]);
        console.log("Last UVs:", particleUvs[(PARTICLES - 1) * 3], particleUvs[(PARTICLES - 1) * 3 + 1], particleUvs[(PARTICLES - 1) * 3 + 2]);

        particlesGeo.setAttribute('position', new THREE.BufferAttribute(particleUvs, 3));

        particleUniforms = {
            texPos: { value: null },
            texVel: { value: null },
            time: { value: 0.0 },
            particleSizeMult: { value: PARTICLE_SIZE_MULT }
        };

        materialParticles = new THREE.ShaderMaterial({
            uniforms: particleUniforms,
            vertexShader: vsParticles,
            fragmentShader: fsParticles,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            depthTest: true,
            vertexColors: false
        });

        particleMesh = new THREE.Points(particlesGeo, materialParticles);
        particleMesh.frustumCulled = false;
        scene.add(particleMesh);
        
        particleUniforms.texPos.value = rtPosition1.texture;
        particleUniforms.texVel.value = rtVelocity1.texture;
        particleUniforms.time.value = performance.now() * 0.001;

        console.log("Particle system initialized:", PARTICLES, "particles");
        console.log("Position RT:", rtPosition1, "Texture:", rtPosition1.texture);
        console.log("Velocity RT:", rtVelocity1, "Texture:", rtVelocity1.texture);

        if (!rtPosition1.texture) {
            console.error("ERROR: Position texture is null!");
        }
        if (!rtVelocity1.texture) {
            console.error("ERROR: Velocity texture is null!");
        }

        // 2. Spacetime Grid
        if (gridEnabled) {
            const gridGeo = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            gridGeo.rotateX(-Math.PI / 2);
            
            gridUniforms = {
                texPos: { value: null },
                lightDir: { value: GRID_LIGHT_DIR.clone() },
                lightColor: { value: GRID_LIGHT_COLOR.clone() },
                ambientIntensity: { value: 0.28 }
            };

            const materialGrid = new THREE.ShaderMaterial({
                uniforms: gridUniforms,
                vertexShader: getVsGrid(TEXTURE_WIDTH),
                fragmentShader: fsGrid,
                transparent: true,
                wireframe: false,
                side: THREE.DoubleSide
            });

            gridMesh = new THREE.Mesh(gridGeo, materialGrid);
            gridMesh.frustumCulled = false;
            gridMesh.visible = gridVisible;
            scene.add(gridMesh);
            updateGridScale();
        }

        simTime = 0;
        if (uiStats.simTimeVal) uiStats.simTimeVal.textContent = '0.0s';
    }

    function rebuildSimulation(mode) {
        applySimulationMode(mode);
        cleanupSimulation();
        setupSimulation();
        setupStatsUI();
        syncGridToggle();
        resetCamera();
        lastFrameTime = performance.now();
        lastFpsSample = lastFrameTime;
        frameCounter = 0;
        const simulationSelect = document.getElementById('simulationSelect');
        if (simulationSelect) simulationSelect.value = simulationMode;
    }

    function syncGridToggle() {
        const gridToggle = document.getElementById('gridToggle');
        if (!gridToggle) return;
        const isDisabled = !gridEnabled || !gridMesh;
        gridToggle.classList.toggle('active', gridVisible && !isDisabled);
        gridToggle.classList.toggle('disabled', isDisabled);
        const gridGroup = gridToggle.closest('.toggle-group');
        if (gridGroup) gridGroup.classList.toggle('disabled', isDisabled);
    }


    function init() {
        // --- Basic Setup ---
        const container = document.getElementById('canvas-container');
        applySimulationMode(simulationMode);
        renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3;
        renderer.physicallyCorrectLights = true;
        
        // Check for required WebGL features
        const gl = renderer.getContext();
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        if (debugInfo) {
            console.log('GPU:', gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL));
        }
        
        if(!renderer.capabilities.floatFragmentTextures) {
            document.getElementById('warning').style.display = 'block';
            document.getElementById('warning').innerText = "Error: OES_texture_float not supported on this device.";
            console.error("Float textures not supported!");
        } else {
            console.log("Float textures supported:", renderer.capabilities.floatFragmentTextures);
        }
        container.appendChild(renderer.domElement);

        scene = new THREE.Scene();
        // scene.fog = new THREE.FogExp2(0x050505, 0.001);

        const directionalLight = new THREE.DirectionalLight(0xf5f1e6, 1.1);
        directionalLight.position.copy(GRID_LIGHT_DIR.clone().multiplyScalar(220));
        directionalLight.target.position.set(0, 0, 0);
        scene.add(directionalLight);
        scene.add(directionalLight.target);

        const hemisphereLight = new THREE.HemisphereLight(0xaab9ff, 0x06040a, 0.25);
        scene.add(hemisphereLight);

        const fillLight = new THREE.PointLight(0x7fa8ff, 0.45, 0, 2);
        fillLight.position.set(-90, 40, -150);
        scene.add(fillLight);

        const coreGlow = new THREE.PointLight(0xfff1d6, 0.25, 600, 2);
        coreGlow.position.set(0, 60, 0);
        scene.add(coreGlow);

        // Subtle starfield backdrop for depth
        const starCount = 1500;
        const starGeo = new THREE.BufferGeometry();
        const starPositions = new Float32Array(starCount * 3);
        const starColors = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const distance = 1800 + Math.random() * 2200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            starPositions[i * 3 + 0] = distance * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = distance * Math.sin(phi) * Math.sin(theta);
            starPositions[i * 3 + 2] = distance * Math.cos(phi);

            const temp = Math.random();
            let r = 1.0;
            let g = 1.0;
            let b = 1.0;
            if (temp < 0.7) {
                const t = temp / 0.7;
                r = 1.0;
                g = 0.78 + 0.18 * t;
                b = 0.55 + 0.35 * t;
            } else {
                const t = (temp - 0.7) / 0.3;
                r = 0.9 - 0.25 * t;
                g = 0.9 - 0.1 * t;
                b = 1.0;
            }
            const brightness = 0.6 + Math.random() * 0.4;
            starColors[i * 3 + 0] = r * brightness;
            starColors[i * 3 + 1] = g * brightness;
            starColors[i * 3 + 2] = b * brightness;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        starGeo.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
        const starTexture = createGlowTexture(128);
        const starMaterial = new THREE.PointsMaterial({
            map: starTexture,
            color: 0xffffff,
            size: 2.2,
            transparent: true,
            opacity: 0.85,
            depthWrite: false,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true,
            alphaTest: 0.02,
            vertexColors: true
        });
        const starField = new THREE.Points(starGeo, starMaterial);
        scene.add(starField);

        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(cameraDefaults.x, cameraDefaults.y, cameraDefaults.z);
        camera.lookAt(0, 0, 0);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        setupSimulation();

        // Events
        window.addEventListener('resize', onWindowResize);
        const resetBtn = document.getElementById('resetBtn');
        if (resetBtn) resetBtn.addEventListener('click', resetSimulation);
        const resetCameraBtn = document.getElementById('resetCameraBtn');
        if (resetCameraBtn) resetCameraBtn.addEventListener('click', resetCamera);
        
        // Keyboard movement controls
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            const code = e.code.toLowerCase();
            keys[key] = true;
            keys[code] = true; // Also track by code for arrow keys and special keys
            
            // Prevent default behavior for movement keys to avoid scrolling
            const movementKeys = ['w', 'a', 's', 'd', 'q', 'e', ' ', 'space', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'shift', 'shiftleft', 'shiftright'];
            if (movementKeys.includes(key) || movementKeys.includes(code)) {
                e.preventDefault();
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            const code = e.code.toLowerCase();
            keys[key] = false;
            keys[code] = false;
        });
        
        // Click handler for adding particles
        setupParticleClickHandler();
        
        // Setup UI handlers
        setupStatsUI();
        setupUIHandlers();

        lastFrameTime = performance.now();
        lastFpsSample = lastFrameTime;
        animate();
    }

    function setupStatsUI() {
        uiStats = {
            particlesVal: document.getElementById('particlesVal'),
            calcVal: document.getElementById('calcVal'),
            fpsVal: document.getElementById('fpsVal'),
            simTimeVal: document.getElementById('simTimeVal'),
            speedDisplay: document.getElementById('speedDisplay')
        };

        if (uiStats.particlesVal) uiStats.particlesVal.textContent = PARTICLES.toString();
        if (uiStats.calcVal) {
            const calcPerFrame = PARTICLES * PARTICLES;
            uiStats.calcVal.textContent = `~${(calcPerFrame / 1e6).toFixed(2)} M`;
        }
        if (uiStats.speedDisplay) uiStats.speedDisplay.textContent = `${speed.toFixed(1)}x`;
        if (uiStats.simTimeVal) uiStats.simTimeVal.textContent = '0.0s';
        if (uiStats.fpsVal) uiStats.fpsVal.textContent = '--';
    }

    function updateGridScale() {
        if (!gridMesh) return;
        const scale = BOUNDS / 1000;
        gridMesh.scale.set(scale, 1, scale);
    }

    function resetCamera() {
        if (!camera || !controls) return;
        camera.position.set(cameraDefaults.x, cameraDefaults.y, cameraDefaults.z);
        controls.target.set(0, 0, 0);
        controls.update();
    }

    function setupUIHandlers() {
        const speedRange = document.getElementById('speedRange');
        const speedDisplay = document.getElementById('speedDisplay');

        const simulationSelect = document.getElementById('simulationSelect');
        if (simulationSelect) {
            simulationSelect.value = simulationMode;
            simulationSelect.addEventListener('change', (e) => {
                const mode = e.target.value;
                if (mode !== simulationMode) {
                    rebuildSimulation(mode);
                }
            });
        }

        // Grid toggle
        const gridToggle = document.getElementById('gridToggle');
        if (gridToggle) {
            gridToggle.addEventListener('click', () => {
                if (!gridEnabled || !gridMesh) return;
                gridVisible = !gridVisible;
                gridMesh.visible = gridVisible;
                syncGridToggle();
            });
            syncGridToggle();
        }

        // UI toggle
        const uiToggle = document.getElementById('uiToggle');
        const ui = document.getElementById('ui');
        let uiVisible = true;
        if (uiToggle && ui) {
            uiToggle.addEventListener('click', () => {
                uiVisible = !uiVisible;
                if (uiVisible) {
                    ui.classList.remove('hidden');
                    uiToggle.textContent = 'Hide UI';
                } else {
                    ui.classList.add('hidden');
                    uiToggle.textContent = 'Show UI';
                }
            });
        }

        // Settings modal
        const settingsModal = document.getElementById('settingsModal');
        const settingsBtn = document.getElementById('settingsBtn');
        const saveSettingsBtn = document.getElementById('saveSettingsBtn');
        const cancelSettingsBtn = document.getElementById('cancelSettingsBtn');
        const settingsSpeed = document.getElementById('settingsSpeed');

        // Load current values into settings modal
        function loadSettingsToModal() {
            document.getElementById('settingsSpeed').value = speed;
            document.getElementById('settingsGravity').value = GRAVITY_CONSTANT;
            document.getElementById('settingsSoftening').value = SOFTENING;
            document.getElementById('settingsDamping').value = DAMPING;
            document.getElementById('settingsMaxVel').value = MAX_VELOCITY;
            document.getElementById('settingsBounds').value = BOUNDS;
            document.getElementById('settingsParticleSize').value = PARTICLE_SIZE_MULT;
            updateSettingsDisplay();
        }

        // Update value displays
        function updateSettingsDisplay() {
            if (!settingsSpeed) return;
            document.getElementById('speedValue').textContent = parseFloat(settingsSpeed.value).toFixed(1);
            document.getElementById('gravityValue').textContent = parseFloat(document.getElementById('settingsGravity').value).toFixed(1);
            document.getElementById('softeningValue').textContent = parseFloat(document.getElementById('settingsSoftening').value).toFixed(1);
            document.getElementById('dampingValue').textContent = parseFloat(document.getElementById('settingsDamping').value).toFixed(4);
            document.getElementById('maxVelValue').textContent = parseFloat(document.getElementById('settingsMaxVel').value).toFixed(1);
            document.getElementById('boundsValue').textContent = parseFloat(document.getElementById('settingsBounds').value).toFixed(0);
            document.getElementById('particleSizeValue').textContent = parseFloat(document.getElementById('settingsParticleSize').value).toFixed(1);
        }

        function applySpeed(value, syncSettings = false) {
            const clamped = Number.isFinite(value) ? Math.max(0, Math.min(2, value)) : 1.0;
            speed = clamped;
            if (speedRange) speedRange.value = speed;
            if (speedDisplay) speedDisplay.textContent = `${speed.toFixed(1)}x`;
            if (syncSettings && settingsSpeed) {
                settingsSpeed.value = speed;
                updateSettingsDisplay();
            }
        }

        // Update shaders when parameters change
        function updateShaders() {
            // Update position shader
            matPos.fragmentShader = getFsPosition();
            matPos.uniforms.bounds.value = BOUNDS;
            matPos.uniforms.boundsHalf.value = BOUNDS_HALF;
            matPos.needsUpdate = true;

            // Update velocity shader
            matVel.fragmentShader = getFsVelocity(TEXTURE_WIDTH);
            matVel.uniforms.gravityConstant.value = GRAVITY_CONSTANT;
            matVel.uniforms.softening.value = SOFTENING;
            matVel.uniforms.damping.value = DAMPING;
            matVel.uniforms.maxVelocity.value = MAX_VELOCITY;
            matVel.needsUpdate = true;

            // Update particle material
            particleUniforms.particleSizeMult.value = PARTICLE_SIZE_MULT;
            updateGridScale();
        }

        // Settings sliders update display
        ['settingsSpeed', 'settingsGravity', 'settingsSoftening', 'settingsDamping', 'settingsMaxVel', 'settingsBounds', 'settingsParticleSize'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.addEventListener('input', updateSettingsDisplay);
        });

        // Open settings modal
        if (settingsBtn && settingsModal) {
            settingsBtn.addEventListener('click', () => {
                loadSettingsToModal();
                settingsModal.classList.add('active');
            });
        }

        // Save settings
        if (saveSettingsBtn && settingsModal && settingsSpeed) {
            saveSettingsBtn.addEventListener('click', () => {
                applySpeed(parseFloat(settingsSpeed.value));
                GRAVITY_CONSTANT = parseFloat(document.getElementById('settingsGravity').value);
                SOFTENING = parseFloat(document.getElementById('settingsSoftening').value);
                DAMPING = parseFloat(document.getElementById('settingsDamping').value);
                MAX_VELOCITY = parseFloat(document.getElementById('settingsMaxVel').value);
                BOUNDS = parseFloat(document.getElementById('settingsBounds').value);
                BOUNDS_HALF = BOUNDS / 2;
                PARTICLE_SIZE_MULT = parseFloat(document.getElementById('settingsParticleSize').value);

                // Update shaders
                updateShaders();

                settingsModal.classList.remove('active');
            });
        }

        // Cancel settings
        if (cancelSettingsBtn && settingsModal) {
            cancelSettingsBtn.addEventListener('click', () => {
                settingsModal.classList.remove('active');
            });
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && settingsModal && settingsModal.classList.contains('active')) {
                settingsModal.classList.remove('active');
            }
        });

        if (speedRange) {
            speedRange.addEventListener('input', e => {
                applySpeed(parseFloat(e.target.value), true);
            });
        }

        applySpeed(speed, true);
    }

    function createRenderTarget(initialData) {
        const rt = new THREE.WebGLRenderTarget(TEXTURE_WIDTH, TEXTURE_WIDTH, {
            wrapS: THREE.ClampToEdgeWrapping,
            wrapT: THREE.ClampToEdgeWrapping,
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBAFormat,
            type: THREE.FloatType, // Crucial for storing physics data
            generateMipmaps: false
        });
        
        // Fill with initial data
        const texture = new THREE.DataTexture(initialData, TEXTURE_WIDTH, TEXTURE_WIDTH, THREE.RGBAFormat, THREE.FloatType);
        texture.needsUpdate = true;
        texture.flipY = false; // Important for render targets
        
        // We render the initial data into the target once
        const tempMat = new THREE.MeshBasicMaterial({ map: texture });
        const tempMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), tempMat);
        const tempScene = new THREE.Scene();
        tempScene.add(tempMesh);
        
        // Ensure renderer is ready
        renderer.setRenderTarget(rt);
        renderer.clear();
        renderer.render(tempScene, cameraFBO);
        renderer.setRenderTarget(null);
        
        // Verify data was written (check first few values)
        if (initialData.length > 0) {
            console.log("Render target created. Sample data:", 
                initialData[0], initialData[1], initialData[2], initialData[3]);
        }
        
        return rt;
    }

    // --- Initialization Logic ---

    function randomUnitVector() {
        const u = Math.random();
        const v = Math.random();
        const theta = u * Math.PI * 2;
        const phi = Math.acos(2 * v - 1);
        return {
            x: Math.sin(phi) * Math.cos(theta),
            y: Math.sin(phi) * Math.sin(theta),
            z: Math.cos(phi)
        };
    }

    function randomInSphere(radius) {
        const dir = randomUnitVector();
        const dist = Math.cbrt(Math.random()) * radius;
        return { x: dir.x * dist, y: dir.y * dist, z: dir.z * dist };
    }

    function randomInShell(minRadius, maxRadius) {
        const dir = randomUnitVector();
        const min3 = Math.pow(minRadius, 3);
        const max3 = Math.pow(maxRadius, 3);
        const dist = Math.cbrt(Math.random() * (max3 - min3) + min3);
        return { x: dir.x * dist, y: dir.y * dist, z: dir.z * dist };
    }

    function randomNormal() {
        return (Math.random() + Math.random() + Math.random() + Math.random() - 2.0) * 0.5;
    }

    function normalizeVec(x, y, z) {
        const len = Math.sqrt(x * x + y * y + z * z) || 1;
        return { x: x / len, y: y / len, z: z / len, len };
    }

    function crossVec(a, b) {
        return {
            x: a.y * b.z - a.z * b.y,
            y: a.z * b.x - a.x * b.z,
            z: a.x * b.y - a.y * b.x
        };
    }

    function getDiskPositions() {
        const data = new Float32Array(PARTICLES * 4);
        const armOffset = (Math.PI * 2) / GALAXY_ARMS;
        webHubs = [];

        for (let i = 0; i < PARTICLES; i++) {
            if (i < CORE_PARTICLES) {
                const spread = 24 + Math.random() * 18;
                data[i * 4 + 0] = (Math.random() - 0.5) * spread;
                data[i * 4 + 1] = (Math.random() - 0.5) * spread * 0.3;
                data[i * 4 + 2] = (Math.random() - 0.5) * spread;
                data[i * 4 + 3] = CENTRAL_MASS + Math.random() * 600;
                continue;
            }

            const armId = i % GALAXY_ARMS;
            const radius = Math.pow(Math.random(), 0.6) * GALAXY_RADIUS + 40;
            const angle = armId * armOffset + radius * GALAXY_TIGHTNESS + (Math.random() - 0.5) * 0.45;
            const heightFalloff = Math.exp(-radius / 220);

            const x = radius * Math.cos(angle);
            const z = radius * Math.sin(angle);
            const y = (Math.random() - 0.5) * GALAXY_HEIGHT * heightFalloff;

            let mass = 1.0 + Math.pow(Math.random(), 3) * 6.5;
            if (Math.random() < 0.008) mass *= 5.5;

            data[i * 4 + 0] = x;
            data[i * 4 + 1] = y;
            data[i * 4 + 2] = z;
            data[i * 4 + 3] = mass;
        }

        return data;
    }

    function getWebPositions() {
        const data = new Float32Array(PARTICLES * 4);
        webHubs = [];

        const universeRadius = WEB_RADIUS * 1.2;
        const heavyCount = Math.max(10, Math.floor(PARTICLES * 0.01));
        const heavyIndices = new Set();
        while (heavyIndices.size < heavyCount) {
            heavyIndices.add(Math.floor(Math.random() * PARTICLES));
        }

        for (let i = 0; i < PARTICLES; i++) {
            const isHeavy = heavyIndices.has(i);
            const pos = isHeavy
                ? randomInShell(WEB_RADIUS * 0.6, universeRadius * 1.1)
                : randomInSphere(universeRadius);

            let mass = 0.6 + Math.random() * 2.6;
            if (isHeavy) {
                mass = HUB_MASS_MIN + Math.random() * (HUB_MASS_MAX - HUB_MASS_MIN);
                webHubs.push({ x: pos.x, y: pos.y, z: pos.z, mass });
            } else if (Math.random() < 0.02) {
                mass *= 3.5;
            }

            data[i * 4 + 0] = pos.x;
            data[i * 4 + 1] = pos.y;
            data[i * 4 + 2] = pos.z;
            data[i * 4 + 3] = mass;
        }

        return data;
    }

    function getInitialPositions() {
        return simulationMode === 'web' ? getWebPositions() : getDiskPositions();
    }

    function getDiskVelocities(posData) {
        const data = new Float32Array(PARTICLES * 4);

        for (let i = 0; i < PARTICLES; i++) {
            const x = posData[i * 4];
            const z = posData[i * 4 + 2];
            const mass = Math.max(posData[i * 4 + 3], 1.0);
            const planarDist = Math.sqrt(x * x + z * z);

            const radialX = planarDist > 0 ? x / planarDist : 0;
            const radialZ = planarDist > 0 ? z / planarDist : 0;
            const tangentX = -radialZ;
            const tangentZ = radialX;

            if (planarDist < 18) {
                const swirlSpeed = 0.6 + Math.random() * 0.8;
                data[i * 4 + 0] = tangentX * swirlSpeed + (Math.random() - 0.5) * 0.3;
                data[i * 4 + 2] = tangentZ * swirlSpeed + (Math.random() - 0.5) * 0.3;
                data[i * 4 + 1] = (Math.random() - 0.5) * 0.2;
            } else {
                const safeDist = Math.max(planarDist, 12.0);
                const centralInfluence = CENTRAL_MASS + mass * 4.0;
                const targetSpeed = Math.sqrt(GRAVITY_CONSTANT * centralInfluence / safeDist);

                data[i * 4 + 0] = tangentX * targetSpeed;
                data[i * 4 + 2] = tangentZ * targetSpeed;
                data[i * 4 + 1] = (Math.random() - 0.5) * 0.12 * targetSpeed;

                const radialJitter = (Math.random() - 0.5) * 0.25 * targetSpeed;
                data[i * 4 + 0] += radialX * radialJitter;
                data[i * 4 + 2] += radialZ * radialJitter;
            }

            data[i * 4 + 3] = 0; // w unused for velocity
        }

        return data;
    }

    function getWebVelocities(posData) {
        const data = new Float32Array(PARTICLES * 4);
        for (let i = 0; i < PARTICLES; i++) {
            const mass = Math.max(posData[i * 4 + 3], 0.6);
            const drift = 0.35 * (1.0 / (1.0 + mass * 0.04));

            data[i * 4 + 0] = randomNormal() * drift;
            data[i * 4 + 1] = randomNormal() * drift;
            data[i * 4 + 2] = randomNormal() * drift;
            data[i * 4 + 3] = 0; // w unused for velocity
        }

        return data;
    }

    function getInitialVelocities(posData) {
        return simulationMode === 'web' ? getWebVelocities(posData) : getDiskVelocities(posData);
    }

    function resetSimulation() {
        const p = getInitialPositions();
        const v = getInitialVelocities(p);
        for (let i = 0; i < PARTICLES; i++) particleMasses[i] = p[i * 4 + 3];
        simTime = 0;
        if (uiStats.simTimeVal) uiStats.simTimeVal.textContent = '0.0s';
        
        // Re-render initial data to buffers
        const rt1 = createRenderTarget(p);
        const rt2 = createRenderTarget(v);
        
        // Copy to main
        const quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial());
        const sc = new THREE.Scene(); sc.add(quad);
        
        // Reset positions
        quad.material.map = rt1.texture;
        renderer.setRenderTarget(rtPosition1); renderer.render(sc, cameraFBO);
        renderer.setRenderTarget(rtPosition2); renderer.render(sc, cameraFBO);
        
        // Reset velocities
        quad.material.map = rt2.texture;
        renderer.setRenderTarget(rtVelocity1); renderer.render(sc, cameraFBO);
        renderer.setRenderTarget(rtVelocity2); renderer.render(sc, cameraFBO);

        renderer.setRenderTarget(null);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // --- Particle Addition Functions ---
    let pendingParticlePosition = null;
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let mouseDownPos = null;
    let isDragging = false;

    function setupParticleClickHandler() {
        const modal = document.getElementById('particleModal');
        const addBtn = document.getElementById('addParticleBtn');
        const cancelBtn = document.getElementById('cancelParticleBtn');
        const massInput = document.getElementById('particleMass');

        // Track mouse down position
        renderer.domElement.addEventListener('mousedown', (event) => {
            // Only handle left mouse button (button 0)
            if (event.button !== 0) return;
            
            // Don't add particle if clicking on UI
            if (event.target.closest('#ui')) return;
            
            // Don't trigger if modifier keys are pressed (used for panning/zooming)
            if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) return;
            
            // Store initial mouse position
            mouseDownPos = { x: event.clientX, y: event.clientY };
            isDragging = false;
        });

        // Track mouse movement to detect dragging
        renderer.domElement.addEventListener('mousemove', (event) => {
            if (mouseDownPos !== null) {
                const dx = event.clientX - mouseDownPos.x;
                const dy = event.clientY - mouseDownPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // If mouse moved more than 5 pixels, consider it a drag
                if (distance > 5) {
                    isDragging = true;
                }
            }
        });

        // Handle mouse up - only add particle if it was a click (not a drag)
        renderer.domElement.addEventListener('mouseup', (event) => {
            // Only handle left mouse button (button 0)
            if (event.button !== 0) {
                mouseDownPos = null;
                isDragging = false;
                return;
            }
            
            // Don't add particle if clicking on UI
            if (event.target.closest('#ui')) {
                mouseDownPos = null;
                isDragging = false;
                return;
            }
            
            // Don't trigger if modifier keys are pressed
            if (event.ctrlKey || event.shiftKey || event.altKey || event.metaKey) {
                mouseDownPos = null;
                isDragging = false;
                return;
            }
            
            // Only proceed if it was a click (not a drag)
            if (mouseDownPos !== null && !isDragging) {
                // Calculate mouse position in normalized device coordinates
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Raycast to find intersection with an invisible plane at y=0
                raycaster.setFromCamera(mouse, camera);
                
                // Create a plane at y=0 to intersect with
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                const intersectionPoint = new THREE.Vector3();
                const hasIntersection = raycaster.ray.intersectPlane(plane, intersectionPoint);
                
                // If we got a valid intersection, open modal
                if (hasIntersection !== null && !isNaN(intersectionPoint.x)) {
                    pendingParticlePosition = intersectionPoint.clone();
                    modal.classList.add('active');
                    massInput.focus();
                    massInput.select();
                }
            }
            
            // Reset tracking
            mouseDownPos = null;
            isDragging = false;
        });

        // Add particle button
        addBtn.addEventListener('click', () => {
            const mass = parseFloat(massInput.value) || 1.0;
            if (pendingParticlePosition && mass > 0) {
                addParticleToSimulation(pendingParticlePosition, mass);
            }
            modal.classList.remove('active');
            pendingParticlePosition = null;
        });

        // Cancel button
        cancelBtn.addEventListener('click', () => {
            modal.classList.remove('active');
            pendingParticlePosition = null;
        });

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.classList.contains('active')) {
                modal.classList.remove('active');
                pendingParticlePosition = null;
            }
        });
    }

    function getSpawnVelocity(position, mass) {
        if (simulationMode !== 'web') {
            const planarDist = Math.sqrt(position.x * position.x + position.z * position.z);
            if (planarDist < 0.001) {
                return new THREE.Vector3(0, 0, 0);
            }

            const tangentX = -position.z / planarDist;
            const tangentZ = position.x / planarDist;
            const safeDist = Math.max(planarDist, 12.0);
            const centralInfluence = CENTRAL_MASS + mass * 4.0;
            const targetSpeed = Math.sqrt(GRAVITY_CONSTANT * centralInfluence / safeDist);

            const vel = new THREE.Vector3(
                tangentX * targetSpeed,
                (Math.random() - 0.5) * 0.12 * targetSpeed,
                tangentZ * targetSpeed
            );

            const radialJitter = (Math.random() - 0.5) * 0.15 * targetSpeed;
            vel.x += (position.x / planarDist) * radialJitter;
            vel.z += (position.z / planarDist) * radialJitter;

            return vel;
        }

        const drift = 0.35 * (1.0 / (1.0 + mass * 0.04));
        return new THREE.Vector3(
            randomNormal() * drift,
            randomNormal() * drift,
            randomNormal() * drift
        );
    }

    function addParticleToSimulation(position, mass) {
        const EMPTY_THRESHOLD = 0.001;

        let slotIndex = -1;
        for (let i = 0; i < PARTICLES; i++) {
            if (particleMasses[i] < EMPTY_THRESHOLD) { slotIndex = i; break; }
        }
        if (slotIndex === -1) {
            let minMass = Infinity;
            for (let i = 0; i < PARTICLES; i++) {
                const m = particleMasses[i];
                if (m < minMass) { minMass = m; slotIndex = i; }
            }
            console.warn(`No empty slot found, replacing particle at index ${slotIndex} with mass ${minMass.toFixed(3)}`);
        }

        particleMasses[slotIndex] = mass;

        const col = slotIndex % TEXTURE_WIDTH;
        const row = Math.floor(slotIndex / TEXTURE_WIDTH);
        const initialVelocity = getSpawnVelocity(position, mass);

        // Inject position into the current position buffer (write to the other buffer, then swap to avoid feedback)
        matInject.uniforms.texIn.value = rtPosition1.texture;
        matInject.uniforms.targetCoord.value.set(col, row);
        matInject.uniforms.newValue.value.set(position.x, position.y, position.z, mass);
        renderer.setRenderTarget(rtPosition2);
        renderer.render(sceneInject, cameraFBO);
        renderer.setRenderTarget(null);
        let tempPos = rtPosition1; rtPosition1 = rtPosition2; rtPosition2 = tempPos;

        // Inject velocity (zero) into the current velocity buffer
        matInject.uniforms.texIn.value = rtVelocity1.texture;
        matInject.uniforms.targetCoord.value.set(col, row);
        matInject.uniforms.newValue.value.set(initialVelocity.x, initialVelocity.y, initialVelocity.z, 0);
        renderer.setRenderTarget(rtVelocity2);
        renderer.render(sceneInject, cameraFBO);
        renderer.setRenderTarget(null);
        let tempVel = rtVelocity1; rtVelocity1 = rtVelocity2; rtVelocity2 = tempVel;

        // Ensure visuals + grid sample the updated current buffers immediately
        if (gridUniforms && gridMesh) {
            gridUniforms.texPos.value = rtPosition1.texture;
        }
        particleUniforms.texPos.value = rtPosition1.texture;
        particleUniforms.texVel.value = rtVelocity1.texture;

        materialParticles.uniformsNeedUpdate = true;
        if (gridMesh) {
            gridMesh.material.uniformsNeedUpdate = true;
        }

        console.log(`Added particle at (${position.x.toFixed(2)}, ${position.y.toFixed(2)}, ${position.z.toFixed(2)}) with mass ${mass} at slot ${slotIndex}`);
    }

    function stepSimulation(dt, nowSeconds) {
        // 1. Update Velocity
        meshVel.visible = true; meshPos.visible = false;
        matVel.uniforms.texPos.value = rtPosition1.texture;
        matVel.uniforms.texVel.value = rtVelocity1.texture;
        matVel.uniforms.delta.value = dt;
        matVel.uniforms.time.value = nowSeconds;

        renderer.setRenderTarget(rtVelocity2);
        renderer.render(sceneFBO, cameraFBO);

        // 2. Update Position
        meshVel.visible = false; meshPos.visible = true;
        matPos.uniforms.texPos.value = rtPosition1.texture;
        matPos.uniforms.texVel.value = rtVelocity2.texture; // Use new velocity
        matPos.uniforms.delta.value = dt;

        renderer.setRenderTarget(rtPosition2);
        renderer.render(sceneFBO, cameraFBO);

        renderer.setRenderTarget(null);

        // Swap Buffers
        let tempPos = rtPosition1; rtPosition1 = rtPosition2; rtPosition2 = tempPos;
        let tempVel = rtVelocity1; rtVelocity1 = rtVelocity2; rtVelocity2 = tempVel;
    }

    function updateStats(now) {
        if (!uiStats.fpsVal || !uiStats.simTimeVal) return;
        frameCounter += 1;
        const elapsed = now - lastFpsSample;
        if (elapsed >= 500) {
            const fps = (frameCounter * 1000) / elapsed;
            uiStats.fpsVal.textContent = fps.toFixed(0);
            uiStats.simTimeVal.textContent = `${simTime.toFixed(1)}s`;
            frameCounter = 0;
            lastFpsSample = now;
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        const now = performance.now();
        const deltaSeconds = Math.min((now - lastFrameTime) / 1000, 0.05);
        lastFrameTime = now;
        const simDelta = deltaSeconds * speed;

        if (speed > 0 && simDelta > 0) {
            const subSteps = Math.min(MAX_SUBSTEPS, Math.max(1, Math.ceil(simDelta / TARGET_STEP)));
            const stepDt = simDelta / subSteps;
            const nowSeconds = now * 0.001;

            for (let i = 0; i < subSteps; i++) {
                stepSimulation(stepDt, nowSeconds);
                simTime += stepDt;
            }
        }

        // --- RENDER STEP ---
        
        // Feed the Simulation Data to the Visuals
        // Always update textures after buffer swap to ensure we're reading from the correct buffer
        particleUniforms.texPos.value = rtPosition1.texture;
        particleUniforms.texVel.value = rtVelocity1.texture;
        particleUniforms.time.value = now * 0.001;
        if (gridUniforms && gridMesh) {
            gridUniforms.texPos.value = rtPosition1.texture;
        }
        
        // Force uniforms update every frame to ensure textures are current
        materialParticles.uniformsNeedUpdate = true;
        if (gridMesh) {
            gridMesh.material.uniformsNeedUpdate = true;
        }
        
        // Keyboard movement
        const moveVector = new THREE.Vector3();
        const moveSpeedFrame = moveSpeed * deltaSeconds * 60; // Normalize to 60fps
        
        // Get camera direction and right vector
        const forward = new THREE.Vector3();
        camera.getWorldDirection(forward);
        const right = new THREE.Vector3();
        right.crossVectors(forward, camera.up).normalize();
        
        // Forward/Backward (W/S or ArrowUp/ArrowDown)
        if (keys['w'] || keys['arrowup']) {
            moveVector.add(forward.clone().multiplyScalar(moveSpeedFrame));
        }
        if (keys['s'] || keys['arrowdown']) {
            moveVector.add(forward.clone().multiplyScalar(-moveSpeedFrame));
        }
        
        // Left/Right (A/D or ArrowLeft/ArrowRight)
        if (keys['a'] || keys['arrowleft']) {
            moveVector.add(right.clone().multiplyScalar(-moveSpeedFrame));
        }
        if (keys['d'] || keys['arrowright']) {
            moveVector.add(right.clone().multiplyScalar(moveSpeedFrame));
        }
        
        // Up/Down (Q/E or Space/Shift)
        if (keys['q'] || keys[' '] || keys['space']) {
            moveVector.add(camera.up.clone().multiplyScalar(moveSpeedFrame));
        }
        if (keys['e'] || keys['shift'] || keys['shiftleft'] || keys['shiftright']) {
            moveVector.add(camera.up.clone().multiplyScalar(-moveSpeedFrame));
        }
        
        // Apply movement
        if (moveVector.length() > 0) {
            camera.position.add(moveVector);
            controls.target.add(moveVector); // Also move the orbit target to maintain relative position
        }
        
        controls.update();
        renderer.render(scene, camera);
        updateStats(now);
    }

    init();

</script>
</body>
</html>
